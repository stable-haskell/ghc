allow-boot-library-installs: True
benchmarks: False
tests: False

packages:
  -- NOTE: we need rts-headers, because the _newly_ built compiler depends
  --       on these potentially _new_ headers, we must not rely on those from
  --       the rts as shipped with the bootstrap compiler. For the stage2
  --       compiler we have the `rts` available, which would have the correct
  --       headers around, now it has them through the rts -> rts-headers
  --       dependency.
  rts-headers
  rts-fs

  -- Compiler
  ghc
  compiler

  -- Internal libraries
  libraries/ghc-boot
  libraries/ghc-boot-th-next
  libraries/ghc-heap
  libraries/ghc-platform
  libraries/ghci

  -- Internal tools
  utils/deriveConstants
  utils/genapply
  utils/genprimopcode
  utils/ghc-pkg
  utils/ghc-toolchain
  utils/ghc-toolchain/exe
  utils/unlit

  -- The following are packages available on Hackage but included as submodules
  libraries/Cabal/Cabal
  libraries/Cabal/Cabal-syntax
  libraries/directory
  libraries/file-io
  libraries/filepath
  libraries/os-string
  libraries/process
  libraries/semaphore-compat
  libraries/unix
  libraries/Win32
  utils/hsc2hs

--
-- Constraints
--

constraints:
  template-haskell <= 2.22

--
-- Package level configuration
--

package *
  library-vanilla: True
  shared: False
  executable-profiling: False
  executable-dynamic: False
  executable-static: False

package ghc
  flags: +bootstrap

package ghci
  flags: +bootstrap

package ghc-boot
  flags: +bootstrap

package ghc-boot-th-next
  flags: +bootstrap

-- TODO: What is this? Why do we need _in-ghc-tree_ here?
package hsc2hs
  flags: +in-ghc-tree

--
-- Program options
--

program-options
  ghc-options: -fhide-source-paths -j
