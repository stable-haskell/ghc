
module Language.Haskell.TH where
  -- Safety: Safe
  type AnnLookup :: *
  data AnnLookup = AnnLookupModule Language.Haskell.TH.Syntax.Module | AnnLookupName Name
  type AnnTarget :: *
  data AnnTarget = ModuleAnnotation | TypeAnnotation Name | ValueAnnotation Name
  type Arity :: *
  type Arity = GHC.Types.Int
  type Bang :: *
  data Bang = Bang SourceUnpackedness SourceStrictness
  type BangQ :: *
  type BangQ = Q Bang
  type BangType :: *
  type BangType = (Bang, Type)
  type BangTypeQ :: *
  type BangTypeQ = Q BangType
  type BndrVis :: *
  data BndrVis = BndrReq | BndrInvis
  type Body :: *
  data Body = GuardedB [(Guard, Exp)] | NormalB Exp
  type BodyQ :: *
  type BodyQ = Q Body
  type Callconv :: *
  data Callconv = CCall | StdCall | CApi | Prim | JavaScript
  type Clause :: *
  data Clause = Clause [Pat] Body [Dec]
  type ClauseQ :: *
  type ClauseQ = Q Clause
  type role Code representational nominal
  type Code :: (* -> *) -> forall (r :: GHC.Types.RuntimeRep). TYPE r -> *
  newtype Code m a = Code {examineCode :: m (TExp a)}
  type CodeQ :: forall (r :: GHC.Types.RuntimeRep). TYPE r -> *
  type CodeQ = Code Q :: forall (r :: GHC.Types.RuntimeRep). TYPE r -> *
  type Con :: *
  data Con = NormalC Name [BangType] | RecC Name [VarBangType] | InfixC BangType Name BangType | ForallC [TyVarBndr Specificity] Cxt Con | GadtC [Name] [BangType] Type | RecGadtC [Name] [VarBangType] Type
  type ConQ :: *
  type ConQ = Q Con
  type Cxt :: *
  type Cxt = [Pred]
  type CxtQ :: *
  type CxtQ = Q Cxt
  type Dec :: *
  data Dec
    = FunD Name [Clause]
    | ValD Pat Body [Dec]
    | DataD Cxt Name [TyVarBndr BndrVis] (GHC.Maybe.Maybe Kind) [Con] [DerivClause]
    | NewtypeD Cxt Name [TyVarBndr BndrVis] (GHC.Maybe.Maybe Kind) Con [DerivClause]
    | TypeDataD Name [TyVarBndr BndrVis] (GHC.Maybe.Maybe Kind) [Con]
    | TySynD Name [TyVarBndr BndrVis] Type
    | ClassD Cxt Name [TyVarBndr BndrVis] [FunDep] [Dec]
    | InstanceD (GHC.Maybe.Maybe Overlap) Cxt Type [Dec]
    | SigD Name Type
    | KiSigD Name Kind
    | ForeignD Foreign
    | InfixD Fixity Name
    | DefaultD [Type]
    | PragmaD Pragma
    | DataFamilyD Name [TyVarBndr BndrVis] (GHC.Maybe.Maybe Kind)
    | DataInstD Cxt (GHC.Maybe.Maybe [TyVarBndr ()]) Type (GHC.Maybe.Maybe Kind) [Con] [DerivClause]
    | NewtypeInstD Cxt (GHC.Maybe.Maybe [TyVarBndr ()]) Type (GHC.Maybe.Maybe Kind) Con [DerivClause]
    | TySynInstD TySynEqn
    | OpenTypeFamilyD TypeFamilyHead
    | ClosedTypeFamilyD TypeFamilyHead [TySynEqn]
    | RoleAnnotD Name [Role]
    | StandaloneDerivD (GHC.Maybe.Maybe DerivStrategy) Cxt Type
    | DefaultSigD Name Type
    | PatSynD Name PatSynArgs PatSynDir Pat
    | PatSynSigD Name PatSynType
    | ImplicitParamBindD GHC.Base.String Exp
  type DecQ :: *
  type DecQ = Q Dec
  type DecidedStrictness :: *
  data DecidedStrictness = DecidedLazy | DecidedStrict | DecidedUnpack
  type DecsQ :: *
  type DecsQ = Q [Dec]
  type DefaultBndrFlag :: * -> Constraint
  class DefaultBndrFlag flag where
    defaultBndrFlag :: flag
    {-# MINIMAL defaultBndrFlag #-}
  type DerivClause :: *
  data DerivClause = DerivClause (GHC.Maybe.Maybe DerivStrategy) Cxt
  type DerivClauseQ :: *
  type DerivClauseQ = Q DerivClause
  type DerivStrategy :: *
  data DerivStrategy = StockStrategy | AnyclassStrategy | NewtypeStrategy | ViaStrategy Type
  type DerivStrategyQ :: *
  type DerivStrategyQ = Q DerivStrategy
  type DocLoc :: *
  data DocLoc = ModuleDoc | DeclDoc Name | ArgDoc Name GHC.Types.Int | InstDoc Type
  type Exp :: *
  data Exp
    = VarE Name
    | ConE Name
    | LitE Lit
    | AppE Exp Exp
    | AppTypeE Exp Type
    | InfixE (GHC.Maybe.Maybe Exp) Exp (GHC.Maybe.Maybe Exp)
    | UInfixE Exp Exp Exp
    | ParensE Exp
    | LamE [Pat] Exp
    | LamCaseE [Match]
    | LamCasesE [Clause]
    | TupE [GHC.Maybe.Maybe Exp]
    | UnboxedTupE [GHC.Maybe.Maybe Exp]
    | UnboxedSumE Exp SumAlt SumArity
    | CondE Exp Exp Exp
    | MultiIfE [(Guard, Exp)]
    | LetE [Dec] Exp
    | CaseE Exp [Match]
    | DoE (GHC.Maybe.Maybe Language.Haskell.TH.Syntax.ModName) [Stmt]
    | MDoE (GHC.Maybe.Maybe Language.Haskell.TH.Syntax.ModName) [Stmt]
    | CompE [Stmt]
    | ArithSeqE Range
    | ListE [Exp]
    | SigE Exp Type
    | RecConE Name [FieldExp]
    | RecUpdE Exp [FieldExp]
    | StaticE Exp
    | UnboundVarE Name
    | LabelE GHC.Base.String
    | ImplicitParamVarE GHC.Base.String
    | GetFieldE Exp GHC.Base.String
    | ProjectionE (GHC.Base.NonEmpty GHC.Base.String)
    | TypedBracketE Exp
    | TypedSpliceE Exp
  type ExpQ :: *
  type ExpQ = Q Exp
  type Extension :: *
  data Extension
    = Cpp
    | OverlappingInstances
    | UndecidableInstances
    | IncoherentInstances
    | UndecidableSuperClasses
    | MonomorphismRestriction
    | MonoLocalBinds
    | DeepSubsumption
    | RelaxedPolyRec
    | ExtendedDefaultRules
    | ForeignFunctionInterface
    | UnliftedFFITypes
    | InterruptibleFFI
    | CApiFFI
    | GHCForeignImportPrim
    | JavaScriptFFI
    | ParallelArrays
    | Arrows
    | TemplateHaskell
    | TemplateHaskellQuotes
    | QualifiedDo
    | QuasiQuotes
    | ImplicitParams
    | ImplicitPrelude
    | ScopedTypeVariables
    | AllowAmbiguousTypes
    | UnboxedTuples
    | UnboxedSums
    | UnliftedNewtypes
    | UnliftedDatatypes
    | BangPatterns
    | TypeFamilies
    | TypeFamilyDependencies
    | TypeInType
    | OverloadedStrings
    | OverloadedLists
    | NumDecimals
    | DisambiguateRecordFields
    | RecordWildCards
    | NamedFieldPuns
    | ViewPatterns
    | GADTs
    | GADTSyntax
    | NPlusKPatterns
    | DoAndIfThenElse
    | BlockArguments
    | RebindableSyntax
    | ConstraintKinds
    | PolyKinds
    | DataKinds
    | TypeData
    | InstanceSigs
    | ApplicativeDo
    | LinearTypes
    | StandaloneDeriving
    | DeriveDataTypeable
    | AutoDeriveTypeable
    | DeriveFunctor
    | DeriveTraversable
    | DeriveFoldable
    | DeriveGeneric
    | DefaultSignatures
    | DeriveAnyClass
    | DeriveLift
    | DerivingStrategies
    | DerivingVia
    | TypeSynonymInstances
    | FlexibleContexts
    | FlexibleInstances
    | ConstrainedClassMethods
    | MultiParamTypeClasses
    | NullaryTypeClasses
    | FunctionalDependencies
    | UnicodeSyntax
    | ExistentialQuantification
    | MagicHash
    | EmptyDataDecls
    | KindSignatures
    | RoleAnnotations
    | ParallelListComp
    | TransformListComp
    | MonadComprehensions
    | GeneralizedNewtypeDeriving
    | RecursiveDo
    | PostfixOperators
    | TupleSections
    | PatternGuards
    | LiberalTypeSynonyms
    | RankNTypes
    | ImpredicativeTypes
    | TypeOperators
    | ExplicitNamespaces
    | PackageImports
    | ExplicitForAll
    | AlternativeLayoutRule
    | AlternativeLayoutRuleTransitional
    | DatatypeContexts
    | NondecreasingIndentation
    | RelaxedLayout
    | TraditionalRecordSyntax
    | LambdaCase
    | MultiWayIf
    | BinaryLiterals
    | NegativeLiterals
    | HexFloatLiterals
    | DuplicateRecordFields
    | OverloadedLabels
    | EmptyCase
    | PatternSynonyms
    | PartialTypeSignatures
    | NamedWildCards
    | StaticPointers
    | TypeApplications
    | Strict
    | StrictData
    | EmptyDataDeriving
    | NumericUnderscores
    | QuantifiedConstraints
    | StarIsType
    | ImportQualifiedPost
    | CUSKs
    | StandaloneKindSignatures
    | LexicalNegation
    | FieldSelectors
    | OverloadedRecordDot
    | OverloadedRecordUpdate
    | TypeAbstractions
    | ExtendedLiterals
  type FamilyResultSig :: *
  data FamilyResultSig = NoSig | KindSig Kind | TyVarSig (TyVarBndr ())
  type FamilyResultSigQ :: *
  type FamilyResultSigQ = Q FamilyResultSig
  type FieldExp :: *
  type FieldExp = (Name, Exp)
  type FieldExpQ :: *
  type FieldExpQ = Q FieldExp
  type FieldPat :: *
  type FieldPat = (Name, Pat)
  type FieldPatQ :: *
  type FieldPatQ = Q FieldPat
  type Fixity :: *
  data Fixity = Fixity GHC.Types.Int FixityDirection
  type FixityDirection :: *
  data FixityDirection = InfixL | InfixR | InfixN
  type Foreign :: *
  data Foreign = ImportF Callconv Safety GHC.Base.String Name Type | ExportF Callconv GHC.Base.String Name Type
  type FunDep :: *
  data FunDep = FunDep [Name] [Name]
  type Guard :: *
  data Guard = NormalG Exp | PatG [Stmt]
  type GuardQ :: *
  type GuardQ = Q Guard
  type Info :: *
  data Info = ClassI Dec [InstanceDec] | ClassOpI Name Type ParentName | TyConI Dec | FamilyI Dec [InstanceDec] | PrimTyConI Name Arity Unlifted | DataConI Name Type ParentName | PatSynI Name PatSynType | VarI Name Type (GHC.Maybe.Maybe Dec) | TyVarI Name Type
  type InfoQ :: *
  type InfoQ = Q Info
  type InjectivityAnn :: *
  data InjectivityAnn = InjectivityAnn Name [Name]
  type Inline :: *
  data Inline = NoInline | Inline | Inlinable
  type InstanceDec :: *
  type InstanceDec = Dec
  type Kind :: *
  type Kind = Type
  type KindQ :: *
  type KindQ = Q Kind
  type Lit :: *
  data Lit = CharL GHC.Types.Char | StringL GHC.Base.String | IntegerL GHC.Num.Integer.Integer | RationalL GHC.Real.Rational | IntPrimL GHC.Num.Integer.Integer | WordPrimL GHC.Num.Integer.Integer | FloatPrimL GHC.Real.Rational | DoublePrimL GHC.Real.Rational | StringPrimL [GHC.Word.Word8] | BytesPrimL Language.Haskell.TH.Syntax.Bytes | CharPrimL GHC.Types.Char
  type Loc :: *
  data Loc = Loc {loc_filename :: GHC.Base.String, loc_package :: GHC.Base.String, loc_module :: GHC.Base.String, loc_start :: Language.Haskell.TH.Syntax.CharPos, loc_end :: Language.Haskell.TH.Syntax.CharPos}
  type Match :: *
  data Match = Match Pat Body [Dec]
  type MatchQ :: *
  type MatchQ = Q Match
  type ModuleInfo :: *
  data ModuleInfo = ModuleInfo [Language.Haskell.TH.Syntax.Module]
  type Name :: *
  data Name = ...
  type NameSpace :: *
  data NameSpace = ...
  type Overlap :: *
  data Overlap = Overlappable | Overlapping | Overlaps | Incoherent
  type ParentName :: *
  type ParentName = Name
  type Pat :: *
  data Pat = LitP Lit | VarP Name | TupP [Pat] | UnboxedTupP [Pat] | UnboxedSumP Pat SumAlt SumArity | ConP Name [Type] [Pat] | InfixP Pat Name Pat | UInfixP Pat Name Pat | ParensP Pat | TildeP Pat | BangP Pat | AsP Name Pat | WildP | RecP Name [FieldPat] | ListP [Pat] | SigP Pat Type | ViewP Exp Pat
  type PatQ :: *
  type PatQ = Q Pat
  type PatSynArgs :: *
  data PatSynArgs = PrefixPatSyn [Name] | InfixPatSyn Name Name | RecordPatSyn [Name]
  type PatSynArgsQ :: *
  type PatSynArgsQ = Q PatSynArgs
  type PatSynDir :: *
  data PatSynDir = Unidir | ImplBidir | ExplBidir [Clause]
  type PatSynDirQ :: *
  type PatSynDirQ = Q PatSynDir
  type PatSynType :: *
  type PatSynType = Type
  type Phases :: *
  data Phases = AllPhases | FromPhase GHC.Types.Int | BeforePhase GHC.Types.Int
  type Ppr :: * -> Constraint
  class Ppr a where
    ppr :: a -> Language.Haskell.TH.PprLib.Doc
    ppr_list :: [a] -> Language.Haskell.TH.PprLib.Doc
    {-# MINIMAL ppr #-}
  type Pragma :: *
  data Pragma = InlineP Name Inline RuleMatch Phases | OpaqueP Name | SpecialiseP Name Type (GHC.Maybe.Maybe Inline) Phases | SpecialiseInstP Type | RuleP GHC.Base.String (GHC.Maybe.Maybe [TyVarBndr ()]) [RuleBndr] Exp Exp Phases | AnnP AnnTarget Exp | LineP GHC.Types.Int GHC.Base.String | CompleteP [Name] (GHC.Maybe.Maybe Name)
  type Pred :: *
  type Pred = Type
  type PredQ :: *
  type PredQ = Q Pred
  type role Q nominal
  type Q :: * -> *
  newtype Q a = ...
  type Quote :: (* -> *) -> Constraint
  class GHC.Base.Monad m => Quote m where
    newName :: GHC.Base.String -> m Name
    {-# MINIMAL newName #-}
  type Range :: *
  data Range = FromR Exp | FromThenR Exp Exp | FromToR Exp Exp | FromThenToR Exp Exp Exp
  type RangeQ :: *
  type RangeQ = Q Range
  type Role :: *
  data Role = NominalR | RepresentationalR | PhantomR | InferR
  type RuleBndr :: *
  data RuleBndr = RuleVar Name | TypedRuleVar Name Type
  type RuleBndrQ :: *
  type RuleBndrQ = Q RuleBndr
  type RuleMatch :: *
  data RuleMatch = ConLike | FunLike
  type Safety :: *
  data Safety = Unsafe | Safe | Interruptible
  type SourceStrictness :: *
  data SourceStrictness = NoSourceStrictness | SourceLazy | SourceStrict
  type SourceStrictnessQ :: *
  type SourceStrictnessQ = Q SourceStrictness
  type SourceUnpackedness :: *
  data SourceUnpackedness = NoSourceUnpackedness | SourceNoUnpack | SourceUnpack
  type SourceUnpackednessQ :: *
  type SourceUnpackednessQ = Q SourceUnpackedness
  type Specificity :: *
  data Specificity = SpecifiedSpec | InferredSpec
  type Stmt :: *
  data Stmt = BindS Pat Exp | LetS [Dec] | NoBindS Exp | ParS [[Stmt]] | RecS [Stmt]
  type StmtQ :: *
  type StmtQ = Q Stmt
  type Strict :: *
  type Strict = Bang
  type StrictTypeQ :: *
  type StrictTypeQ = Q Language.Haskell.TH.Syntax.StrictType
  type SumAlt :: *
  type SumAlt = GHC.Types.Int
  type SumArity :: *
  type SumArity = GHC.Types.Int
  type role TExp nominal
  type TExp :: forall (r :: GHC.Types.RuntimeRep). TYPE r -> *
  newtype TExp a = Language.Haskell.TH.Syntax.TExp {unType :: Exp}
  type TExpQ :: forall (r :: GHC.Types.RuntimeRep). TYPE r -> *
  type TExpQ a = Q (TExp a)
  type TyLit :: *
  data TyLit = NumTyLit GHC.Num.Integer.Integer | StrTyLit GHC.Base.String | CharTyLit GHC.Types.Char
  type TyLitQ :: *
  type TyLitQ = Q TyLit
  type TySynEqn :: *
  data TySynEqn = TySynEqn (GHC.Maybe.Maybe [TyVarBndr ()]) Type Type
  type TySynEqnQ :: *
  type TySynEqnQ = Q TySynEqn
  type TyVarBndr :: * -> *
  data TyVarBndr flag = PlainTV Name flag | KindedTV Name flag Kind
  type TyVarBndrSpec :: *
  type TyVarBndrSpec = TyVarBndr Specificity
  type TyVarBndrUnit :: *
  type TyVarBndrUnit = TyVarBndr ()
  type TyVarBndrVis :: *
  type TyVarBndrVis = TyVarBndr BndrVis
  type Type :: *
  data Type = ForallT [TyVarBndr Specificity] Cxt Type | ForallVisT [TyVarBndr ()] Type | AppT Type Type | AppKindT Type Kind | SigT Type Kind | VarT Name | ConT Name | PromotedT Name | InfixT Type Name Type | UInfixT Type Name Type | PromotedInfixT Type Name Type | PromotedUInfixT Type Name Type | ParensT Type | TupleT GHC.Types.Int | UnboxedTupleT GHC.Types.Int | UnboxedSumT SumArity | ArrowT | MulArrowT | EqualityT | ListT | PromotedTupleT GHC.Types.Int | PromotedNilT | PromotedConsT | StarT | ConstraintT | LitT TyLit | WildCardT | ImplicitParamT GHC.Base.String Type
  type TypeFamilyHead :: *
  data TypeFamilyHead = TypeFamilyHead Name [TyVarBndr BndrVis] FamilyResultSig (GHC.Maybe.Maybe InjectivityAnn)
  type TypeQ :: *
  type TypeQ = Q Type
  type Unlifted :: *
  type Unlifted = GHC.Types.Bool
  type VarBangType :: *
  type VarBangType = (Name, Bang, Type)
  type VarBangTypeQ :: *
  type VarBangTypeQ = Q VarBangType
  type VarStrictTypeQ :: *
  type VarStrictTypeQ = Q Language.Haskell.TH.Syntax.VarStrictType
  anyclassStrategy :: forall (m :: * -> *). Quote m => m DerivStrategy
  appE :: forall (m :: * -> *). Quote m => m Exp -> m Exp -> m Exp
  appK :: Kind -> Kind -> Kind
  appKindT :: forall (m :: * -> *). Quote m => m Type -> m Kind -> m Type
  appT :: forall (m :: * -> *). Quote m => m Type -> m Type -> m Type
  appTypeE :: forall (m :: * -> *). Quote m => m Exp -> m Type -> m Exp
  appsE :: forall (m :: * -> *). Quote m => [m Exp] -> m Exp
  arithSeqE :: forall (m :: * -> *). Quote m => m Range -> m Exp
  arrowK :: Kind
  arrowT :: forall (m :: * -> *). Quote m => m Type
  asP :: forall (m :: * -> *). Quote m => Name -> m Pat -> m Pat
  bang :: forall (m :: * -> *). Quote m => m SourceUnpackedness -> m SourceStrictness -> m Bang
  bangP :: forall (m :: * -> *). Quote m => m Pat -> m Pat
  bangType :: forall (m :: * -> *). Quote m => m Bang -> m Type -> m BangType
  bindCode :: forall (m :: * -> *) a (r :: GHC.Types.RuntimeRep) (b :: TYPE r). GHC.Base.Monad m => m a -> (a -> Code m b) -> Code m b
  bindCode_ :: forall (m :: * -> *) a (r :: GHC.Types.RuntimeRep) (b :: TYPE r). GHC.Base.Monad m => m a -> Code m b -> Code m b
  bindS :: forall (m :: * -> *). Quote m => m Pat -> m Exp -> m Stmt
  bndrInvis :: BndrVis
  bndrReq :: BndrVis
  bytesPrimL :: Language.Haskell.TH.Syntax.Bytes -> Lit
  cApi :: Callconv
  cCall :: Callconv
  caseE :: forall (m :: * -> *). Quote m => m Exp -> [m Match] -> m Exp
  charL :: GHC.Types.Char -> Lit
  charPrimL :: GHC.Types.Char -> Lit
  charTyLit :: forall (m :: * -> *). Quote m => GHC.Types.Char -> m TyLit
  classD :: forall (m :: * -> *). Quote m => m Cxt -> Name -> [TyVarBndr BndrVis] -> [FunDep] -> [m Dec] -> m Dec
  classP :: forall (m :: * -> *). Quote m => Name -> [m Type] -> m Pred
  clause :: forall (m :: * -> *). Quote m => [m Pat] -> m Body -> [m Dec] -> m Clause
  closedTypeFamilyD :: forall (m :: * -> *). Quote m => Name -> [TyVarBndr BndrVis] -> FamilyResultSig -> GHC.Maybe.Maybe InjectivityAnn -> [m TySynEqn] -> m Dec
  compE :: forall (m :: * -> *). Quote m => [m Stmt] -> m Exp
  conE :: forall (m :: * -> *). Quote m => Name -> m Exp
  conK :: Name -> Kind
  conP :: forall (m :: * -> *). Quote m => Name -> [m Pat] -> m Pat
  conT :: forall (m :: * -> *). Quote m => Name -> m Type
  condE :: forall (m :: * -> *). Quote m => m Exp -> m Exp -> m Exp -> m Exp
  constraintK :: Kind
  cxt :: forall (m :: * -> *). Quote m => [m Pred] -> m Cxt
  dataD :: forall (m :: * -> *). Quote m => m Cxt -> Name -> [TyVarBndr BndrVis] -> GHC.Maybe.Maybe Kind -> [m Con] -> [m DerivClause] -> m Dec
  dataD_doc :: Q Cxt -> Name -> [Q (TyVarBndr BndrVis)] -> GHC.Maybe.Maybe (Q Kind) -> [(Q Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String])] -> [Q DerivClause] -> GHC.Maybe.Maybe GHC.Base.String -> Q Dec
  dataFamilyD :: forall (m :: * -> *). Quote m => Name -> [TyVarBndr BndrVis] -> GHC.Maybe.Maybe Kind -> m Dec
  dataInstD :: forall (m :: * -> *). Quote m => m Cxt -> Name -> [m Type] -> GHC.Maybe.Maybe Kind -> [m Con] -> [m DerivClause] -> m Dec
  dataInstD_doc :: Q Cxt -> GHC.Maybe.Maybe [Q (TyVarBndr ())] -> Q Type -> GHC.Maybe.Maybe (Q Kind) -> [(Q Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String])] -> [Q DerivClause] -> GHC.Maybe.Maybe GHC.Base.String -> Q Dec
  defaultD :: forall (m :: * -> *). Quote m => [m Type] -> m Dec
  defaultFixity :: Fixity
  defaultSigD :: forall (m :: * -> *). Quote m => Name -> m Type -> m Dec
  derivClause :: forall (m :: * -> *). Quote m => GHC.Maybe.Maybe DerivStrategy -> [m Pred] -> m DerivClause
  doE :: forall (m :: * -> *). Quote m => [m Stmt] -> m Exp
  doublePrimL :: GHC.Real.Rational -> Lit
  dyn :: forall (m :: * -> *). Quote m => GHC.Base.String -> m Exp
  equalP :: forall (m :: * -> *). Quote m => m Type -> m Type -> m Pred
  equalityT :: forall (m :: * -> *). Quote m => m Type
  explBidir :: forall (m :: * -> *). Quote m => [m Clause] -> m PatSynDir
  extsEnabled :: Q [Extension]
  fieldExp :: forall (m :: * -> *). Quote m => Name -> m Exp -> m (Name, Exp)
  fieldPat :: forall (m :: * -> *). Quote m => Name -> m Pat -> m FieldPat
  floatPrimL :: GHC.Real.Rational -> Lit
  forImpD :: forall (m :: * -> *). Quote m => Callconv -> Safety -> GHC.Base.String -> Name -> m Type -> m Dec
  forallC :: forall (m :: * -> *). Quote m => [TyVarBndr Specificity] -> m Cxt -> m Con -> m Con
  forallT :: forall (m :: * -> *). Quote m => [TyVarBndr Specificity] -> m Cxt -> m Type -> m Type
  forallVisT :: forall (m :: * -> *). Quote m => [m (TyVarBndr ())] -> m Type -> m Type
  fromE :: forall (m :: * -> *). Quote m => m Exp -> m Exp
  fromR :: forall (m :: * -> *). Quote m => m Exp -> m Range
  fromThenE :: forall (m :: * -> *). Quote m => m Exp -> m Exp -> m Exp
  fromThenR :: forall (m :: * -> *). Quote m => m Exp -> m Exp -> m Range
  fromThenToE :: forall (m :: * -> *). Quote m => m Exp -> m Exp -> m Exp -> m Exp
  fromThenToR :: forall (m :: * -> *). Quote m => m Exp -> m Exp -> m Exp -> m Range
  fromToE :: forall (m :: * -> *). Quote m => m Exp -> m Exp -> m Exp
  fromToR :: forall (m :: * -> *). Quote m => m Exp -> m Exp -> m Range
  funD :: forall (m :: * -> *). Quote m => Name -> [m Clause] -> m Dec
  funD_doc :: Name -> [Q Clause] -> GHC.Maybe.Maybe GHC.Base.String -> [GHC.Maybe.Maybe GHC.Base.String] -> Q Dec
  funDep :: [Name] -> [Name] -> FunDep
  gadtC :: forall (m :: * -> *). Quote m => [Name] -> [m Language.Haskell.TH.Syntax.StrictType] -> m Type -> m Con
  getDoc :: DocLoc -> Q (GHC.Maybe.Maybe GHC.Base.String)
  getFieldE :: forall (m :: * -> *). Quote m => m Exp -> GHC.Base.String -> m Exp
  guardedB :: forall (m :: * -> *). Quote m => [m (Guard, Exp)] -> m Body
  hoistCode :: forall (m :: * -> *) (n :: * -> *) (r :: GHC.Types.RuntimeRep) (a :: TYPE r). GHC.Base.Monad m => (forall x. m x -> n x) -> Code m a -> Code n a
  implBidir :: forall (m :: * -> *). Quote m => m PatSynDir
  implicitParamBindD :: forall (m :: * -> *). Quote m => GHC.Base.String -> m Exp -> m Dec
  implicitParamT :: forall (m :: * -> *). Quote m => GHC.Base.String -> m Type -> m Type
  implicitParamVarE :: forall (m :: * -> *). Quote m => GHC.Base.String -> m Exp
  inferR :: Language.Haskell.TH.Lib.Internal.Role
  inferredSpec :: Specificity
  infixApp :: forall (m :: * -> *). Quote m => m Exp -> m Exp -> m Exp -> m Exp
  infixC :: forall (m :: * -> *). Quote m => m (Bang, Type) -> Name -> m (Bang, Type) -> m Con
  infixE :: forall (m :: * -> *). Quote m => GHC.Maybe.Maybe (m Exp) -> m Exp -> GHC.Maybe.Maybe (m Exp) -> m Exp
  infixLD :: forall (m :: * -> *). Quote m => GHC.Types.Int -> Name -> m Dec
  infixND :: forall (m :: * -> *). Quote m => GHC.Types.Int -> Name -> m Dec
  infixP :: forall (m :: * -> *). Quote m => m Pat -> Name -> m Pat -> m Pat
  infixPatSyn :: forall (m :: * -> *). Quote m => Name -> Name -> m PatSynArgs
  infixRD :: forall (m :: * -> *). Quote m => GHC.Types.Int -> Name -> m Dec
  infixT :: forall (m :: * -> *). Quote m => m Type -> Name -> m Type -> m Type
  injectivityAnn :: Name -> [Name] -> Language.Haskell.TH.Lib.Internal.InjectivityAnn
  instanceD :: forall (m :: * -> *). Quote m => m Cxt -> m Type -> [m Dec] -> m Dec
  instanceWithOverlapD :: forall (m :: * -> *). Quote m => GHC.Maybe.Maybe Overlap -> m Cxt -> m Type -> [m Dec] -> m Dec
  intPrimL :: GHC.Num.Integer.Integer -> Lit
  integerL :: GHC.Num.Integer.Integer -> Lit
  interruptible :: Safety
  isExtEnabled :: Extension -> Q GHC.Types.Bool
  isInstance :: Name -> [Type] -> Q GHC.Types.Bool
  isStrict :: forall (m :: * -> *). Quote m => m Strict
  javaScript :: Callconv
  joinCode :: forall (m :: * -> *) (r :: GHC.Types.RuntimeRep) (a :: TYPE r). GHC.Base.Monad m => m (Code m a) -> Code m a
  kiSigD :: forall (m :: * -> *). Quote m => Name -> m Kind -> m Dec
  kindSig :: Kind -> FamilyResultSig
  kindedBndrTV :: forall (m :: * -> *). Quote m => Name -> BndrVis -> m Kind -> m (TyVarBndr BndrVis)
  kindedInvisTV :: forall (m :: * -> *). Quote m => Name -> Specificity -> m Kind -> m (TyVarBndr Specificity)
  kindedTV :: forall flag. DefaultBndrFlag flag => Name -> Kind -> TyVarBndr flag
  labelE :: forall (m :: * -> *). Quote m => GHC.Base.String -> m Exp
  lam1E :: forall (m :: * -> *). Quote m => m Pat -> m Exp -> m Exp
  lamCaseE :: forall (m :: * -> *). Quote m => [m Match] -> m Exp
  lamCasesE :: forall (m :: * -> *). Quote m => [m Clause] -> m Exp
  lamE :: forall (m :: * -> *). Quote m => [m Pat] -> m Exp -> m Exp
  letE :: forall (m :: * -> *). Quote m => [m Dec] -> m Exp -> m Exp
  letS :: forall (m :: * -> *). Quote m => [m Dec] -> m Stmt
  liftCode :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r) (m :: * -> *). m (TExp a) -> Code m a
  listE :: forall (m :: * -> *). Quote m => [m Exp] -> m Exp
  listK :: Kind
  listP :: forall (m :: * -> *). Quote m => [m Pat] -> m Pat
  listT :: forall (m :: * -> *). Quote m => m Type
  litE :: forall (m :: * -> *). Quote m => Lit -> m Exp
  litP :: forall (m :: * -> *). Quote m => Lit -> m Pat
  litT :: forall (m :: * -> *). Quote m => m TyLit -> m Type
  location :: Q Loc
  lookupTypeName :: GHC.Base.String -> Q (GHC.Maybe.Maybe Name)
  lookupValueName :: GHC.Base.String -> Q (GHC.Maybe.Maybe Name)
  match :: forall (m :: * -> *). Quote m => m Pat -> m Body -> [m Dec] -> m Match
  maxPrecedence :: GHC.Types.Int
  mdoE :: forall (m :: * -> *). Quote m => [m Stmt] -> m Exp
  mkBytes :: GHC.ForeignPtr.ForeignPtr GHC.Word.Word8 -> GHC.Types.Word -> GHC.Types.Word -> Language.Haskell.TH.Syntax.Bytes
  mkName :: GHC.Base.String -> Name
  moduleAnnotation :: AnnTarget
  mulArrowT :: forall (m :: * -> *). Quote m => m Type
  multiIfE :: forall (m :: * -> *). Quote m => [m (Guard, Exp)] -> m Exp
  nameBase :: Name -> GHC.Base.String
  nameModule :: Name -> GHC.Maybe.Maybe GHC.Base.String
  namePackage :: Name -> GHC.Maybe.Maybe GHC.Base.String
  nameSpace :: Name -> GHC.Maybe.Maybe NameSpace
  newDeclarationGroup :: Q [Dec]
  newtypeD :: forall (m :: * -> *). Quote m => m Cxt -> Name -> [TyVarBndr BndrVis] -> GHC.Maybe.Maybe Kind -> m Con -> [m DerivClause] -> m Dec
  newtypeD_doc :: Q Cxt -> Name -> [Q (TyVarBndr BndrVis)] -> GHC.Maybe.Maybe (Q Kind) -> (Q Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String]) -> [Q DerivClause] -> GHC.Maybe.Maybe GHC.Base.String -> Q Dec
  newtypeInstD :: forall (m :: * -> *). Quote m => m Cxt -> Name -> [m Type] -> GHC.Maybe.Maybe Kind -> m Con -> [m DerivClause] -> m Dec
  newtypeInstD_doc :: Q Cxt -> GHC.Maybe.Maybe [Q (TyVarBndr ())] -> Q Type -> GHC.Maybe.Maybe (Q Kind) -> (Q Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String]) -> [Q DerivClause] -> GHC.Maybe.Maybe GHC.Base.String -> Q Dec
  newtypeStrategy :: forall (m :: * -> *). Quote m => m DerivStrategy
  noBindS :: forall (m :: * -> *). Quote m => m Exp -> m Stmt
  noSig :: FamilyResultSig
  noSourceStrictness :: forall (m :: * -> *). Quote m => m SourceStrictness
  noSourceUnpackedness :: forall (m :: * -> *). Quote m => m SourceUnpackedness
  nominalR :: Language.Haskell.TH.Lib.Internal.Role
  normalB :: forall (m :: * -> *). Quote m => m Exp -> m Body
  normalC :: forall (m :: * -> *). Quote m => Name -> [m BangType] -> m Con
  normalG :: forall (m :: * -> *). Quote m => m Exp -> m Guard
  normalGE :: forall (m :: * -> *). Quote m => m Exp -> m Exp -> m (Guard, Exp)
  notStrict :: forall (m :: * -> *). Quote m => m Strict
  numTyLit :: forall (m :: * -> *). Quote m => GHC.Num.Integer.Integer -> m TyLit
  openTypeFamilyD :: forall (m :: * -> *). Quote m => Name -> [TyVarBndr BndrVis] -> FamilyResultSig -> GHC.Maybe.Maybe InjectivityAnn -> m Dec
  parS :: forall (m :: * -> *). Quote m => [[m Stmt]] -> m Stmt
  parensE :: forall (m :: * -> *). Quote m => m Exp -> m Exp
  parensP :: forall (m :: * -> *). Quote m => m Pat -> m Pat
  parensT :: forall (m :: * -> *). Quote m => m Type -> m Type
  patG :: forall (m :: * -> *). Quote m => [m Stmt] -> m Guard
  patGE :: forall (m :: * -> *). Quote m => [m Stmt] -> m Exp -> m (Guard, Exp)
  patSynD :: forall (m :: * -> *). Quote m => Name -> m PatSynArgs -> m PatSynDir -> m Pat -> m Dec
  patSynD_doc :: Name -> Q PatSynArgs -> Q PatSynDir -> Q Pat -> GHC.Maybe.Maybe GHC.Base.String -> [GHC.Maybe.Maybe GHC.Base.String] -> Q Dec
  patSynSigD :: forall (m :: * -> *). Quote m => Name -> m Type -> m Dec
  phantomR :: Language.Haskell.TH.Lib.Internal.Role
  plainBndrTV :: forall (m :: * -> *). Quote m => Name -> BndrVis -> m (TyVarBndr BndrVis)
  plainInvisTV :: forall (m :: * -> *). Quote m => Name -> Specificity -> m (TyVarBndr Specificity)
  plainTV :: forall flag. DefaultBndrFlag flag => Name -> TyVarBndr flag
  pprExp :: Language.Haskell.TH.Ppr.Precedence -> Exp -> Language.Haskell.TH.PprLib.Doc
  pprLit :: Language.Haskell.TH.Ppr.Precedence -> Lit -> Language.Haskell.TH.PprLib.Doc
  pprParendType :: Type -> Language.Haskell.TH.PprLib.Doc
  pprPat :: Language.Haskell.TH.Ppr.Precedence -> Pat -> Language.Haskell.TH.PprLib.Doc
  pprint :: forall a. Ppr a => a -> GHC.Base.String
  pragAnnD :: forall (m :: * -> *). Quote m => AnnTarget -> m Exp -> m Dec
  pragCompleteD :: forall (m :: * -> *). Quote m => [Name] -> GHC.Maybe.Maybe Name -> m Dec
  pragInlD :: forall (m :: * -> *). Quote m => Name -> Inline -> RuleMatch -> Phases -> m Dec
  pragLineD :: forall (m :: * -> *). Quote m => GHC.Types.Int -> GHC.Base.String -> m Dec
  pragRuleD :: forall (m :: * -> *). Quote m => GHC.Base.String -> [m RuleBndr] -> m Exp -> m Exp -> Phases -> m Dec
  pragSpecD :: forall (m :: * -> *). Quote m => Name -> m Type -> Phases -> m Dec
  pragSpecInlD :: forall (m :: * -> *). Quote m => Name -> m Type -> Inline -> Phases -> m Dec
  pragSpecInstD :: forall (m :: * -> *). Quote m => m Type -> m Dec
  prefixPatSyn :: forall (m :: * -> *). Quote m => [Name] -> m PatSynArgs
  prim :: Callconv
  projectionE :: forall (m :: * -> *). Quote m => GHC.Base.NonEmpty GHC.Base.String -> m Exp
  promotedConsT :: forall (m :: * -> *). Quote m => m Type
  promotedInfixT :: forall (m :: * -> *). Quote m => m Type -> Name -> m Type -> m Type
  promotedNilT :: forall (m :: * -> *). Quote m => m Type
  promotedT :: forall (m :: * -> *). Quote m => Name -> m Type
  promotedTupleT :: forall (m :: * -> *). Quote m => GHC.Types.Int -> m Type
  promotedUInfixT :: forall (m :: * -> *). Quote m => m Type -> Name -> m Type -> m Type
  putDoc :: DocLoc -> GHC.Base.String -> Q ()
  rationalL :: GHC.Real.Rational -> Lit
  recC :: forall (m :: * -> *). Quote m => Name -> [m VarBangType] -> m Con
  recConE :: forall (m :: * -> *). Quote m => Name -> [m (Name, Exp)] -> m Exp
  recGadtC :: forall (m :: * -> *). Quote m => [Name] -> [m Language.Haskell.TH.Syntax.VarStrictType] -> m Type -> m Con
  recP :: forall (m :: * -> *). Quote m => Name -> [m FieldPat] -> m Pat
  recS :: forall (m :: * -> *). Quote m => [m Stmt] -> m Stmt
  recUpdE :: forall (m :: * -> *). Quote m => m Exp -> [m (Name, Exp)] -> m Exp
  recordPatSyn :: forall (m :: * -> *). Quote m => [Name] -> m PatSynArgs
  recover :: forall a. Q a -> Q a -> Q a
  reify :: Name -> Q Info
  reifyAnnotations :: forall a. Data.Data.Data a => AnnLookup -> Q [a]
  reifyConStrictness :: Name -> Q [DecidedStrictness]
  reifyFixity :: Name -> Q (GHC.Maybe.Maybe Fixity)
  reifyInstances :: Name -> [Type] -> Q [InstanceDec]
  reifyModule :: Language.Haskell.TH.Syntax.Module -> Q ModuleInfo
  reifyRoles :: Name -> Q [Role]
  reifyType :: Name -> Q Type
  report :: GHC.Types.Bool -> GHC.Base.String -> Q ()
  reportError :: GHC.Base.String -> Q ()
  reportWarning :: GHC.Base.String -> Q ()
  representationalR :: Language.Haskell.TH.Lib.Internal.Role
  roleAnnotD :: forall (m :: * -> *). Quote m => Name -> [Language.Haskell.TH.Lib.Internal.Role] -> m Dec
  ruleVar :: forall (m :: * -> *). Quote m => Name -> m RuleBndr
  runIO :: forall a. GHC.Types.IO a -> Q a
  runQ :: forall (m :: * -> *) a. Language.Haskell.TH.Syntax.Quasi m => Q a -> m a
  safe :: Safety
  sectionL :: forall (m :: * -> *). Quote m => m Exp -> m Exp -> m Exp
  sectionR :: forall (m :: * -> *). Quote m => m Exp -> m Exp -> m Exp
  sigD :: forall (m :: * -> *). Quote m => Name -> m Type -> m Dec
  sigE :: forall (m :: * -> *). Quote m => m Exp -> m Type -> m Exp
  sigP :: forall (m :: * -> *). Quote m => m Pat -> m Type -> m Pat
  sigT :: forall (m :: * -> *). Quote m => m Type -> Kind -> m Type
  sourceLazy :: forall (m :: * -> *). Quote m => m SourceStrictness
  sourceNoUnpack :: forall (m :: * -> *). Quote m => m SourceUnpackedness
  sourceStrict :: forall (m :: * -> *). Quote m => m SourceStrictness
  sourceUnpack :: forall (m :: * -> *). Quote m => m SourceUnpackedness
  specifiedSpec :: Specificity
  standaloneDerivD :: forall (m :: * -> *). Quote m => m Cxt -> m Type -> m Dec
  standaloneDerivWithStrategyD :: forall (m :: * -> *). Quote m => GHC.Maybe.Maybe DerivStrategy -> m Cxt -> m Type -> m Dec
  starK :: Kind
  staticE :: forall (m :: * -> *). Quote m => m Exp -> m Exp
  stdCall :: Callconv
  stockStrategy :: forall (m :: * -> *). Quote m => m DerivStrategy
  strTyLit :: forall (m :: * -> *). Quote m => GHC.Base.String -> m TyLit
  strictType :: forall (m :: * -> *). Quote m => m Strict -> m Type -> m Language.Haskell.TH.Syntax.StrictType
  stringE :: forall (m :: * -> *). Quote m => GHC.Base.String -> m Exp
  stringL :: GHC.Base.String -> Lit
  stringPrimL :: [GHC.Word.Word8] -> Lit
  thisModule :: Q Language.Haskell.TH.Syntax.Module
  tildeP :: forall (m :: * -> *). Quote m => m Pat -> m Pat
  tupE :: forall (m :: * -> *). Quote m => [m Exp] -> m Exp
  tupP :: forall (m :: * -> *). Quote m => [m Pat] -> m Pat
  tupleDataName :: GHC.Types.Int -> Name
  tupleK :: GHC.Types.Int -> Kind
  tupleT :: forall (m :: * -> *). Quote m => GHC.Types.Int -> m Type
  tupleTypeName :: GHC.Types.Int -> Name
  tySynD :: forall (m :: * -> *). Quote m => Name -> [TyVarBndr BndrVis] -> m Type -> m Dec
  tySynEqn :: forall (m :: * -> *). Quote m => GHC.Maybe.Maybe [TyVarBndr ()] -> m Type -> m Type -> m TySynEqn
  tySynInstD :: forall (m :: * -> *). Quote m => m TySynEqn -> m Dec
  tyVarSig :: TyVarBndr () -> FamilyResultSig
  typeAnnotation :: Name -> AnnTarget
  typeDataD :: forall (m :: * -> *). Quote m => Name -> [TyVarBndr BndrVis] -> GHC.Maybe.Maybe Kind -> [m Con] -> m Dec
  typeDataD_doc :: Name -> [Q (TyVarBndr BndrVis)] -> GHC.Maybe.Maybe (Q Kind) -> [(Q Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String])] -> GHC.Maybe.Maybe GHC.Base.String -> Q Dec
  typedBracketE :: forall (m :: * -> *). Quote m => m Exp -> m Exp
  typedRuleVar :: forall (m :: * -> *). Quote m => Name -> m Type -> m RuleBndr
  typedSpliceE :: forall (m :: * -> *). Quote m => m Exp -> m Exp
  uInfixE :: forall (m :: * -> *). Quote m => m Exp -> m Exp -> m Exp -> m Exp
  uInfixP :: forall (m :: * -> *). Quote m => m Pat -> Name -> m Pat -> m Pat
  uInfixT :: forall (m :: * -> *). Quote m => m Type -> Name -> m Type -> m Type
  unTypeCode :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r) (m :: * -> *). Quote m => Code m a -> m Exp
  unboundVarE :: forall (m :: * -> *). Quote m => Name -> m Exp
  unboxedSumDataName :: SumAlt -> SumArity -> Name
  unboxedSumE :: forall (m :: * -> *). Quote m => m Exp -> SumAlt -> SumArity -> m Exp
  unboxedSumP :: forall (m :: * -> *). Quote m => m Pat -> SumAlt -> SumArity -> m Pat
  unboxedSumT :: forall (m :: * -> *). Quote m => SumArity -> m Type
  unboxedSumTypeName :: SumArity -> Name
  unboxedTupE :: forall (m :: * -> *). Quote m => [m Exp] -> m Exp
  unboxedTupP :: forall (m :: * -> *). Quote m => [m Pat] -> m Pat
  unboxedTupleDataName :: GHC.Types.Int -> Name
  unboxedTupleT :: forall (m :: * -> *). Quote m => GHC.Types.Int -> m Type
  unboxedTupleTypeName :: GHC.Types.Int -> Name
  unidir :: forall (m :: * -> *). Quote m => m PatSynDir
  unpacked :: forall (m :: * -> *). Quote m => m Strict
  unsafe :: Safety
  unsafeCodeCoerce :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r) (m :: * -> *). Quote m => m Exp -> Code m a
  valD :: forall (m :: * -> *). Quote m => m Pat -> m Body -> [m Dec] -> m Dec
  valueAnnotation :: Name -> AnnTarget
  varBangType :: forall (m :: * -> *). Quote m => Name -> m BangType -> m VarBangType
  varE :: forall (m :: * -> *). Quote m => Name -> m Exp
  varK :: Name -> Kind
  varP :: forall (m :: * -> *). Quote m => Name -> m Pat
  varStrictType :: forall (m :: * -> *). Quote m => Name -> m Language.Haskell.TH.Syntax.StrictType -> m Language.Haskell.TH.Syntax.VarStrictType
  varT :: forall (m :: * -> *). Quote m => Name -> m Type
  viaStrategy :: forall (m :: * -> *). Quote m => m Type -> m DerivStrategy
  viewP :: forall (m :: * -> *). Quote m => m Exp -> m Pat -> m Pat
  wildCardT :: forall (m :: * -> *). Quote m => m Type
  wildP :: forall (m :: * -> *). Quote m => m Pat
  withDecDoc :: GHC.Base.String -> Q Dec -> Q Dec
  withDecsDoc :: GHC.Base.String -> Q [Dec] -> Q [Dec]
  wordPrimL :: GHC.Num.Integer.Integer -> Lit

module Language.Haskell.TH.CodeDo where
  -- Safety: Safe-Inferred
  (>>) :: forall (m :: * -> *) a b. GHC.Base.Monad m => m a -> Language.Haskell.TH.Syntax.Code m b -> Language.Haskell.TH.Syntax.Code m b
  (>>=) :: forall (m :: * -> *) a b. GHC.Base.Monad m => m a -> (a -> Language.Haskell.TH.Syntax.Code m b) -> Language.Haskell.TH.Syntax.Code m b

module Language.Haskell.TH.LanguageExtensions where
  -- Safety: Safe
  type Extension :: *
  data Extension
    = Cpp
    | OverlappingInstances
    | UndecidableInstances
    | IncoherentInstances
    | UndecidableSuperClasses
    | MonomorphismRestriction
    | MonoLocalBinds
    | DeepSubsumption
    | RelaxedPolyRec
    | ExtendedDefaultRules
    | ForeignFunctionInterface
    | UnliftedFFITypes
    | InterruptibleFFI
    | CApiFFI
    | GHCForeignImportPrim
    | JavaScriptFFI
    | ParallelArrays
    | Arrows
    | TemplateHaskell
    | TemplateHaskellQuotes
    | QualifiedDo
    | QuasiQuotes
    | ImplicitParams
    | ImplicitPrelude
    | ScopedTypeVariables
    | AllowAmbiguousTypes
    | UnboxedTuples
    | UnboxedSums
    | UnliftedNewtypes
    | UnliftedDatatypes
    | BangPatterns
    | TypeFamilies
    | TypeFamilyDependencies
    | TypeInType
    | OverloadedStrings
    | OverloadedLists
    | NumDecimals
    | DisambiguateRecordFields
    | RecordWildCards
    | NamedFieldPuns
    | ViewPatterns
    | GADTs
    | GADTSyntax
    | NPlusKPatterns
    | DoAndIfThenElse
    | BlockArguments
    | RebindableSyntax
    | ConstraintKinds
    | PolyKinds
    | DataKinds
    | TypeData
    | InstanceSigs
    | ApplicativeDo
    | LinearTypes
    | StandaloneDeriving
    | DeriveDataTypeable
    | AutoDeriveTypeable
    | DeriveFunctor
    | DeriveTraversable
    | DeriveFoldable
    | DeriveGeneric
    | DefaultSignatures
    | DeriveAnyClass
    | DeriveLift
    | DerivingStrategies
    | DerivingVia
    | TypeSynonymInstances
    | FlexibleContexts
    | FlexibleInstances
    | ConstrainedClassMethods
    | MultiParamTypeClasses
    | NullaryTypeClasses
    | FunctionalDependencies
    | UnicodeSyntax
    | ExistentialQuantification
    | MagicHash
    | EmptyDataDecls
    | KindSignatures
    | RoleAnnotations
    | ParallelListComp
    | TransformListComp
    | MonadComprehensions
    | GeneralizedNewtypeDeriving
    | RecursiveDo
    | PostfixOperators
    | TupleSections
    | PatternGuards
    | LiberalTypeSynonyms
    | RankNTypes
    | ImpredicativeTypes
    | TypeOperators
    | ExplicitNamespaces
    | PackageImports
    | ExplicitForAll
    | AlternativeLayoutRule
    | AlternativeLayoutRuleTransitional
    | DatatypeContexts
    | NondecreasingIndentation
    | RelaxedLayout
    | TraditionalRecordSyntax
    | LambdaCase
    | MultiWayIf
    | BinaryLiterals
    | NegativeLiterals
    | HexFloatLiterals
    | DuplicateRecordFields
    | OverloadedLabels
    | EmptyCase
    | PatternSynonyms
    | PartialTypeSignatures
    | NamedWildCards
    | StaticPointers
    | TypeApplications
    | Strict
    | StrictData
    | EmptyDataDeriving
    | NumericUnderscores
    | QuantifiedConstraints
    | StarIsType
    | ImportQualifiedPost
    | CUSKs
    | StandaloneKindSignatures
    | LexicalNegation
    | FieldSelectors
    | OverloadedRecordDot
    | OverloadedRecordUpdate
    | TypeAbstractions
    | ExtendedLiterals

module Language.Haskell.TH.Lib where
  -- Safety: Safe
  type BangQ :: *
  type BangQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Bang
  type BangTypeQ :: *
  type BangTypeQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.BangType
  type BodyQ :: *
  type BodyQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Body
  type ClauseQ :: *
  type ClauseQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Clause
  type CodeQ :: forall (r :: GHC.Types.RuntimeRep). TYPE r -> *
  type CodeQ = Language.Haskell.TH.Syntax.Code Language.Haskell.TH.Syntax.Q :: forall (r :: GHC.Types.RuntimeRep). TYPE r -> *
  type ConQ :: *
  type ConQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Con
  type CxtQ :: *
  type CxtQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Cxt
  type DecQ :: *
  type DecQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  type DecsQ :: *
  type DecsQ = Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  type DefaultBndrFlag :: * -> Constraint
  class DefaultBndrFlag flag where
    defaultBndrFlag :: flag
    {-# MINIMAL defaultBndrFlag #-}
  type DerivClause :: *
  data DerivClause = DerivClause (GHC.Maybe.Maybe DerivStrategy) Language.Haskell.TH.Syntax.Cxt
  type DerivClauseQ :: *
  type DerivClauseQ = Language.Haskell.TH.Syntax.Q DerivClause
  type DerivStrategy :: *
  data DerivStrategy = StockStrategy | AnyclassStrategy | NewtypeStrategy | ViaStrategy Language.Haskell.TH.Syntax.Type
  type DerivStrategyQ :: *
  type DerivStrategyQ = Language.Haskell.TH.Syntax.Q DerivStrategy
  type ExpQ :: *
  type ExpQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
  type FamilyResultSigQ :: *
  type FamilyResultSigQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.FamilyResultSig
  type FieldExpQ :: *
  type FieldExpQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.FieldExp
  type FieldPatQ :: *
  type FieldPatQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.FieldPat
  type GuardQ :: *
  type GuardQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Guard
  type InfoQ :: *
  type InfoQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Info
  type KindQ :: *
  type KindQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Kind
  type MatchQ :: *
  type MatchQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Match
  type Overlap :: *
  data Overlap = Overlappable | Overlapping | Overlaps | Incoherent
  type PatQ :: *
  type PatQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Pat
  type PatSynArgsQ :: *
  type PatSynArgsQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.PatSynArgs
  type PatSynDirQ :: *
  type PatSynDirQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.PatSynDir
  type PredQ :: *
  type PredQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Pred
  type RangeQ :: *
  type RangeQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Range
  type RuleBndrQ :: *
  type RuleBndrQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.RuleBndr
  type SourceStrictnessQ :: *
  type SourceStrictnessQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.SourceStrictness
  type SourceUnpackednessQ :: *
  type SourceUnpackednessQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.SourceUnpackedness
  type StmtQ :: *
  type StmtQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Stmt
  type StrictTypeQ :: *
  type StrictTypeQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.StrictType
  type TExpQ :: forall (r :: GHC.Types.RuntimeRep). TYPE r -> *
  type TExpQ a = Language.Haskell.TH.Syntax.Q (Language.Haskell.TH.Syntax.TExp a)
  type TyLitQ :: *
  type TyLitQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
  type TySynEqnQ :: *
  type TySynEqnQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TySynEqn
  type TyVarBndrSpec :: *
  type TyVarBndrSpec = Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.Specificity
  type TyVarBndrUnit :: *
  type TyVarBndrUnit = Language.Haskell.TH.Syntax.TyVarBndr ()
  type TyVarBndrVis :: *
  type TyVarBndrVis = Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis
  type TypeQ :: *
  type TypeQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
  type VarBangTypeQ :: *
  type VarBangTypeQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.VarBangType
  type VarStrictTypeQ :: *
  type VarStrictTypeQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.VarStrictType
  anyclassStrategy :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m DerivStrategy
  appE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  appK :: Language.Haskell.TH.Syntax.Kind -> Language.Haskell.TH.Syntax.Kind -> Language.Haskell.TH.Syntax.Kind
  appKindT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Kind -> m Language.Haskell.TH.Syntax.Type
  appT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  appTypeE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Exp
  appsE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Exp] -> m Language.Haskell.TH.Syntax.Exp
  arithSeqE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Range -> m Language.Haskell.TH.Syntax.Exp
  arrowK :: Language.Haskell.TH.Syntax.Kind
  arrowT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type
  asP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Pat
  bang :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.SourceUnpackedness -> m Language.Haskell.TH.Syntax.SourceStrictness -> m Language.Haskell.TH.Syntax.Bang
  bangP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Pat
  bangType :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Bang -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.BangType
  bindS :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Stmt
  bndrInvis :: Language.Haskell.TH.Syntax.BndrVis
  bndrReq :: Language.Haskell.TH.Syntax.BndrVis
  bytesPrimL :: Language.Haskell.TH.Syntax.Bytes -> Language.Haskell.TH.Syntax.Lit
  cApi :: Language.Haskell.TH.Syntax.Callconv
  cCall :: Language.Haskell.TH.Syntax.Callconv
  caseE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> [m Language.Haskell.TH.Syntax.Match] -> m Language.Haskell.TH.Syntax.Exp
  charL :: GHC.Types.Char -> Language.Haskell.TH.Syntax.Lit
  charPrimL :: GHC.Types.Char -> Language.Haskell.TH.Syntax.Lit
  charTyLit :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Char -> m Language.Haskell.TH.Syntax.TyLit
  classD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis] -> [Language.Haskell.TH.Syntax.FunDep] -> [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Dec
  classP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m Language.Haskell.TH.Syntax.Type] -> m Language.Haskell.TH.Syntax.Pred
  clause :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Pat] -> m Language.Haskell.TH.Syntax.Body -> [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Clause
  closedTypeFamilyD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis] -> Language.Haskell.TH.Syntax.FamilyResultSig -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.InjectivityAnn -> [m Language.Haskell.TH.Syntax.TySynEqn] -> m Language.Haskell.TH.Syntax.Dec
  compE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Stmt] -> m Language.Haskell.TH.Syntax.Exp
  conE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Exp
  conK :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Kind
  conP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m Language.Haskell.TH.Syntax.Pat] -> m Language.Haskell.TH.Syntax.Pat
  conT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type
  condE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  constraintK :: Language.Haskell.TH.Syntax.Kind
  cxt :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Pred] -> m Language.Haskell.TH.Syntax.Cxt
  dataD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis] -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Kind -> [m Language.Haskell.TH.Syntax.Con] -> [m DerivClause] -> m Language.Haskell.TH.Syntax.Dec
  dataD_doc :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.Q (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)] -> GHC.Maybe.Maybe (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Kind) -> [(Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String])] -> [Language.Haskell.TH.Syntax.Q DerivClause] -> GHC.Maybe.Maybe GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  dataFamilyD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis] -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Kind -> m Language.Haskell.TH.Syntax.Dec
  dataInstD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Name -> [m Language.Haskell.TH.Syntax.Type] -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Kind -> [m Language.Haskell.TH.Syntax.Con] -> [m DerivClause] -> m Language.Haskell.TH.Syntax.Dec
  dataInstD_doc :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Cxt -> GHC.Maybe.Maybe [Language.Haskell.TH.Syntax.Q (Language.Haskell.TH.Syntax.TyVarBndr ())] -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type -> GHC.Maybe.Maybe (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Kind) -> [(Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String])] -> [Language.Haskell.TH.Syntax.Q DerivClause] -> GHC.Maybe.Maybe GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  defaultD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Type] -> m Language.Haskell.TH.Syntax.Dec
  defaultSigD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  derivClause :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Maybe.Maybe DerivStrategy -> [m Language.Haskell.TH.Syntax.Pred] -> m DerivClause
  doE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Stmt] -> m Language.Haskell.TH.Syntax.Exp
  doublePrimL :: GHC.Real.Rational -> Language.Haskell.TH.Syntax.Lit
  dyn :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> m Language.Haskell.TH.Syntax.Exp
  equalP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Pred
  equalityT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type
  explBidir :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Clause] -> m Language.Haskell.TH.Syntax.PatSynDir
  fieldExp :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Exp -> m (Language.Haskell.TH.Syntax.Name, Language.Haskell.TH.Syntax.Exp)
  fieldPat :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.FieldPat
  floatPrimL :: GHC.Real.Rational -> Language.Haskell.TH.Syntax.Lit
  forImpD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Callconv -> Language.Haskell.TH.Syntax.Safety -> GHC.Base.String -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  forallC :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.Specificity] -> m Language.Haskell.TH.Syntax.Cxt -> m Language.Haskell.TH.Syntax.Con -> m Language.Haskell.TH.Syntax.Con
  forallT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.Specificity] -> m Language.Haskell.TH.Syntax.Cxt -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  forallVisT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m (Language.Haskell.TH.Syntax.TyVarBndr ())] -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  fromE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  fromR :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Range
  fromThenE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  fromThenR :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Range
  fromThenToE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  fromThenToR :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Range
  fromToE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  fromToR :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Range
  funD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m Language.Haskell.TH.Syntax.Clause] -> m Language.Haskell.TH.Syntax.Dec
  funD_doc :: Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Clause] -> GHC.Maybe.Maybe GHC.Base.String -> [GHC.Maybe.Maybe GHC.Base.String] -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  funDep :: [Language.Haskell.TH.Syntax.Name] -> [Language.Haskell.TH.Syntax.Name] -> Language.Haskell.TH.Syntax.FunDep
  gadtC :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [Language.Haskell.TH.Syntax.Name] -> [m Language.Haskell.TH.Syntax.StrictType] -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Con
  getFieldE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> GHC.Base.String -> m Language.Haskell.TH.Syntax.Exp
  guardedB :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m (Language.Haskell.TH.Syntax.Guard, Language.Haskell.TH.Syntax.Exp)] -> m Language.Haskell.TH.Syntax.Body
  implBidir :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.PatSynDir
  implicitParamBindD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Dec
  implicitParamT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  implicitParamVarE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> m Language.Haskell.TH.Syntax.Exp
  inferR :: Language.Haskell.TH.Lib.Internal.Role
  inferredSpec :: Language.Haskell.TH.Syntax.Specificity
  infixApp :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  infixC :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m (Language.Haskell.TH.Syntax.Bang, Language.Haskell.TH.Syntax.Type) -> Language.Haskell.TH.Syntax.Name -> m (Language.Haskell.TH.Syntax.Bang, Language.Haskell.TH.Syntax.Type) -> m Language.Haskell.TH.Syntax.Con
  infixE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.Exp) -> m Language.Haskell.TH.Syntax.Exp -> GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.Exp) -> m Language.Haskell.TH.Syntax.Exp
  infixLD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Int -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Dec
  infixND :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Int -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Dec
  infixP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Pat
  infixPatSyn :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.PatSynArgs
  infixRD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Int -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Dec
  infixT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  injectivityAnn :: Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.Name] -> Language.Haskell.TH.Lib.Internal.InjectivityAnn
  instanceD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Cxt -> m Language.Haskell.TH.Syntax.Type -> [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Dec
  instanceWithOverlapD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Maybe.Maybe Overlap -> m Language.Haskell.TH.Syntax.Cxt -> m Language.Haskell.TH.Syntax.Type -> [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Dec
  intPrimL :: GHC.Num.Integer.Integer -> Language.Haskell.TH.Syntax.Lit
  integerL :: GHC.Num.Integer.Integer -> Language.Haskell.TH.Syntax.Lit
  interruptible :: Language.Haskell.TH.Syntax.Safety
  isStrict :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Strict
  javaScript :: Language.Haskell.TH.Syntax.Callconv
  kiSigD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Kind -> m Language.Haskell.TH.Syntax.Dec
  kindSig :: Language.Haskell.TH.Syntax.Kind -> Language.Haskell.TH.Syntax.FamilyResultSig
  kindedBndrTV :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.BndrVis -> m Language.Haskell.TH.Syntax.Kind -> m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)
  kindedInvisTV :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Specificity -> m Language.Haskell.TH.Syntax.Kind -> m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.Specificity)
  kindedTV :: forall flag. DefaultBndrFlag flag => Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Kind -> Language.Haskell.TH.Syntax.TyVarBndr flag
  labelE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> m Language.Haskell.TH.Syntax.Exp
  lam1E :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  lamCaseE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Match] -> m Language.Haskell.TH.Syntax.Exp
  lamCasesE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Clause] -> m Language.Haskell.TH.Syntax.Exp
  lamE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Pat] -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  letE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  letS :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Stmt
  listE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Exp] -> m Language.Haskell.TH.Syntax.Exp
  listK :: Language.Haskell.TH.Syntax.Kind
  listP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Pat] -> m Language.Haskell.TH.Syntax.Pat
  listT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type
  litE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Lit -> m Language.Haskell.TH.Syntax.Exp
  litP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Lit -> m Language.Haskell.TH.Syntax.Pat
  litT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.TyLit -> m Language.Haskell.TH.Syntax.Type
  match :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Body -> [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Match
  mdoE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Stmt] -> m Language.Haskell.TH.Syntax.Exp
  mkBytes :: GHC.ForeignPtr.ForeignPtr GHC.Word.Word8 -> GHC.Types.Word -> GHC.Types.Word -> Language.Haskell.TH.Syntax.Bytes
  moduleAnnotation :: Language.Haskell.TH.Syntax.AnnTarget
  mulArrowT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type
  multiIfE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m (Language.Haskell.TH.Syntax.Guard, Language.Haskell.TH.Syntax.Exp)] -> m Language.Haskell.TH.Syntax.Exp
  newtypeD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis] -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Kind -> m Language.Haskell.TH.Syntax.Con -> [m DerivClause] -> m Language.Haskell.TH.Syntax.Dec
  newtypeD_doc :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.Q (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)] -> GHC.Maybe.Maybe (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Kind) -> (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String]) -> [Language.Haskell.TH.Syntax.Q DerivClause] -> GHC.Maybe.Maybe GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  newtypeInstD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Name -> [m Language.Haskell.TH.Syntax.Type] -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Kind -> m Language.Haskell.TH.Syntax.Con -> [m DerivClause] -> m Language.Haskell.TH.Syntax.Dec
  newtypeInstD_doc :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Cxt -> GHC.Maybe.Maybe [Language.Haskell.TH.Syntax.Q (Language.Haskell.TH.Syntax.TyVarBndr ())] -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type -> GHC.Maybe.Maybe (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Kind) -> (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String]) -> [Language.Haskell.TH.Syntax.Q DerivClause] -> GHC.Maybe.Maybe GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  newtypeStrategy :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m DerivStrategy
  noBindS :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Stmt
  noSig :: Language.Haskell.TH.Syntax.FamilyResultSig
  noSourceStrictness :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.SourceStrictness
  noSourceUnpackedness :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.SourceUnpackedness
  nominalR :: Language.Haskell.TH.Lib.Internal.Role
  normalB :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Body
  normalC :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m Language.Haskell.TH.Syntax.BangType] -> m Language.Haskell.TH.Syntax.Con
  normalG :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Guard
  normalGE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m (Language.Haskell.TH.Syntax.Guard, Language.Haskell.TH.Syntax.Exp)
  notStrict :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Strict
  numTyLit :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Num.Integer.Integer -> m Language.Haskell.TH.Syntax.TyLit
  openTypeFamilyD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis] -> Language.Haskell.TH.Syntax.FamilyResultSig -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.InjectivityAnn -> m Language.Haskell.TH.Syntax.Dec
  parS :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [[m Language.Haskell.TH.Syntax.Stmt]] -> m Language.Haskell.TH.Syntax.Stmt
  parensE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  parensP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Pat
  parensT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  patG :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Stmt] -> m Language.Haskell.TH.Syntax.Guard
  patGE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Stmt] -> m Language.Haskell.TH.Syntax.Exp -> m (Language.Haskell.TH.Syntax.Guard, Language.Haskell.TH.Syntax.Exp)
  patSynD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.PatSynArgs -> m Language.Haskell.TH.Syntax.PatSynDir -> m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Dec
  patSynD_doc :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.PatSynArgs -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.PatSynDir -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Pat -> GHC.Maybe.Maybe GHC.Base.String -> [GHC.Maybe.Maybe GHC.Base.String] -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  patSynSigD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  phantomR :: Language.Haskell.TH.Lib.Internal.Role
  plainBndrTV :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.BndrVis -> m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)
  plainInvisTV :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Specificity -> m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.Specificity)
  plainTV :: forall flag. DefaultBndrFlag flag => Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.TyVarBndr flag
  pragAnnD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.AnnTarget -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Dec
  pragCompleteD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [Language.Haskell.TH.Syntax.Name] -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Dec
  pragInlD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Inline -> Language.Haskell.TH.Syntax.RuleMatch -> Language.Haskell.TH.Syntax.Phases -> m Language.Haskell.TH.Syntax.Dec
  pragLineD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Int -> GHC.Base.String -> m Language.Haskell.TH.Syntax.Dec
  pragRuleD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> [m Language.Haskell.TH.Syntax.RuleBndr] -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> Language.Haskell.TH.Syntax.Phases -> m Language.Haskell.TH.Syntax.Dec
  pragSpecD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.Syntax.Phases -> m Language.Haskell.TH.Syntax.Dec
  pragSpecInlD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.Syntax.Inline -> Language.Haskell.TH.Syntax.Phases -> m Language.Haskell.TH.Syntax.Dec
  pragSpecInstD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  prefixPatSyn :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [Language.Haskell.TH.Syntax.Name] -> m Language.Haskell.TH.Syntax.PatSynArgs
  prim :: Language.Haskell.TH.Syntax.Callconv
  projectionE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.NonEmpty GHC.Base.String -> m Language.Haskell.TH.Syntax.Exp
  promotedConsT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type
  promotedInfixT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  promotedNilT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type
  promotedT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type
  promotedTupleT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Int -> m Language.Haskell.TH.Syntax.Type
  promotedUInfixT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  rationalL :: GHC.Real.Rational -> Language.Haskell.TH.Syntax.Lit
  recC :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m Language.Haskell.TH.Syntax.VarBangType] -> m Language.Haskell.TH.Syntax.Con
  recConE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m (Language.Haskell.TH.Syntax.Name, Language.Haskell.TH.Syntax.Exp)] -> m Language.Haskell.TH.Syntax.Exp
  recGadtC :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [Language.Haskell.TH.Syntax.Name] -> [m Language.Haskell.TH.Syntax.VarStrictType] -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Con
  recP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m Language.Haskell.TH.Syntax.FieldPat] -> m Language.Haskell.TH.Syntax.Pat
  recS :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Stmt] -> m Language.Haskell.TH.Syntax.Stmt
  recUpdE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> [m (Language.Haskell.TH.Syntax.Name, Language.Haskell.TH.Syntax.Exp)] -> m Language.Haskell.TH.Syntax.Exp
  recordPatSyn :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [Language.Haskell.TH.Syntax.Name] -> m Language.Haskell.TH.Syntax.PatSynArgs
  representationalR :: Language.Haskell.TH.Lib.Internal.Role
  roleAnnotD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Lib.Internal.Role] -> m Language.Haskell.TH.Syntax.Dec
  ruleVar :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.RuleBndr
  safe :: Language.Haskell.TH.Syntax.Safety
  sectionL :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  sectionR :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  sigD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  sigE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Exp
  sigP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Pat
  sigT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.Syntax.Kind -> m Language.Haskell.TH.Syntax.Type
  sourceLazy :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.SourceStrictness
  sourceNoUnpack :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.SourceUnpackedness
  sourceStrict :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.SourceStrictness
  sourceUnpack :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.SourceUnpackedness
  specifiedSpec :: Language.Haskell.TH.Syntax.Specificity
  standaloneDerivD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Cxt -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  standaloneDerivWithStrategyD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Maybe.Maybe DerivStrategy -> m Language.Haskell.TH.Syntax.Cxt -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  starK :: Language.Haskell.TH.Syntax.Kind
  staticE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  stdCall :: Language.Haskell.TH.Syntax.Callconv
  stockStrategy :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m DerivStrategy
  strTyLit :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> m Language.Haskell.TH.Syntax.TyLit
  strictType :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Strict -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.StrictType
  stringE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> m Language.Haskell.TH.Syntax.Exp
  stringL :: GHC.Base.String -> Language.Haskell.TH.Syntax.Lit
  stringPrimL :: [GHC.Word.Word8] -> Language.Haskell.TH.Syntax.Lit
  thisModule :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Module
  tildeP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Pat
  tupE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Exp] -> m Language.Haskell.TH.Syntax.Exp
  tupP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Pat] -> m Language.Haskell.TH.Syntax.Pat
  tupleK :: GHC.Types.Int -> Language.Haskell.TH.Syntax.Kind
  tupleT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Int -> m Language.Haskell.TH.Syntax.Type
  tySynD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis] -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  tySynEqn :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Maybe.Maybe [Language.Haskell.TH.Syntax.TyVarBndr ()] -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.TySynEqn
  tySynInstD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.TySynEqn -> m Language.Haskell.TH.Syntax.Dec
  tyVarSig :: Language.Haskell.TH.Syntax.TyVarBndr () -> Language.Haskell.TH.Syntax.FamilyResultSig
  typeAnnotation :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.AnnTarget
  typeDataD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis] -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Kind -> [m Language.Haskell.TH.Syntax.Con] -> m Language.Haskell.TH.Syntax.Dec
  typeDataD_doc :: Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.Q (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)] -> GHC.Maybe.Maybe (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Kind) -> [(Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String])] -> GHC.Maybe.Maybe GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  typedBracketE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  typedRuleVar :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.RuleBndr
  typedSpliceE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  uInfixE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  uInfixP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Pat
  uInfixT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  unboundVarE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Exp
  unboxedSumE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> Language.Haskell.TH.Syntax.SumAlt -> Language.Haskell.TH.Syntax.SumArity -> m Language.Haskell.TH.Syntax.Exp
  unboxedSumP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> Language.Haskell.TH.Syntax.SumAlt -> Language.Haskell.TH.Syntax.SumArity -> m Language.Haskell.TH.Syntax.Pat
  unboxedSumT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.SumArity -> m Language.Haskell.TH.Syntax.Type
  unboxedTupE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Exp] -> m Language.Haskell.TH.Syntax.Exp
  unboxedTupP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Pat] -> m Language.Haskell.TH.Syntax.Pat
  unboxedTupleT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Int -> m Language.Haskell.TH.Syntax.Type
  unidir :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.PatSynDir
  unpacked :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Strict
  unsafe :: Language.Haskell.TH.Syntax.Safety
  valD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Body -> [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Dec
  valueAnnotation :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.AnnTarget
  varBangType :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.BangType -> m Language.Haskell.TH.Syntax.VarBangType
  varE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Exp
  varK :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Kind
  varP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Pat
  varStrictType :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.StrictType -> m Language.Haskell.TH.Syntax.VarStrictType
  varT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type
  viaStrategy :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> m DerivStrategy
  viewP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Pat
  wildCardT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type
  wildP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat
  withDecDoc :: GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  withDecsDoc :: GHC.Base.String -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec] -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  wordPrimL :: GHC.Num.Integer.Integer -> Language.Haskell.TH.Syntax.Lit

module Language.Haskell.TH.Lib.Internal where
  -- Safety: Trustworthy
  type BangQ :: *
  type BangQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Bang
  type BangTypeQ :: *
  type BangTypeQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.BangType
  type BodyQ :: *
  type BodyQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Body
  type ClauseQ :: *
  type ClauseQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Clause
  type CodeQ :: forall (r :: GHC.Types.RuntimeRep). TYPE r -> *
  type CodeQ = Language.Haskell.TH.Syntax.Code Language.Haskell.TH.Syntax.Q :: forall (r :: GHC.Types.RuntimeRep). TYPE r -> *
  type ConQ :: *
  type ConQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Con
  type CxtQ :: *
  type CxtQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Cxt
  type DecQ :: *
  type DecQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  type Decs :: *
  type Decs = [Language.Haskell.TH.Syntax.Dec]
  type DecsQ :: *
  type DecsQ = Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  type DerivClauseQ :: *
  type DerivClauseQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.DerivClause
  type DerivStrategyQ :: *
  type DerivStrategyQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.DerivStrategy
  type ExpQ :: *
  type ExpQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
  type FamilyResultSigQ :: *
  type FamilyResultSigQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.FamilyResultSig
  type FieldExpQ :: *
  type FieldExpQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.FieldExp
  type FieldPatQ :: *
  type FieldPatQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.FieldPat
  type GuardQ :: *
  type GuardQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Guard
  type InfoQ :: *
  type InfoQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Info
  type InjectivityAnn :: *
  type InjectivityAnn = Language.Haskell.TH.Syntax.InjectivityAnn
  type KindQ :: *
  type KindQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Kind
  type MatchQ :: *
  type MatchQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Match
  type PatQ :: *
  type PatQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Pat
  type PatSynArgsQ :: *
  type PatSynArgsQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.PatSynArgs
  type PatSynDirQ :: *
  type PatSynDirQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.PatSynDir
  type PredQ :: *
  type PredQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Pred
  type RangeQ :: *
  type RangeQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Range
  type Role :: *
  type Role = Language.Haskell.TH.Syntax.Role
  type RuleBndrQ :: *
  type RuleBndrQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.RuleBndr
  type SourceStrictnessQ :: *
  type SourceStrictnessQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.SourceStrictness
  type SourceUnpackednessQ :: *
  type SourceUnpackednessQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.SourceUnpackedness
  type StmtQ :: *
  type StmtQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Stmt
  type StrictTypeQ :: *
  type StrictTypeQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.StrictType
  type TExpQ :: forall (r :: GHC.Types.RuntimeRep). TYPE r -> *
  type TExpQ a = Language.Haskell.TH.Syntax.Q (Language.Haskell.TH.Syntax.TExp a)
  type TyLitQ :: *
  type TyLitQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
  type TySynEqnQ :: *
  type TySynEqnQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TySynEqn
  type TyVarBndrSpec :: *
  type TyVarBndrSpec = Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.Specificity
  type TyVarBndrUnit :: *
  type TyVarBndrUnit = Language.Haskell.TH.Syntax.TyVarBndr ()
  type TyVarBndrVis :: *
  type TyVarBndrVis = Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis
  type TypeQ :: *
  type TypeQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
  type VarBangTypeQ :: *
  type VarBangTypeQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.VarBangType
  type VarStrictTypeQ :: *
  type VarStrictTypeQ = Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.VarStrictType
  anyclassStrategy :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.DerivStrategy
  appE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  appK :: Language.Haskell.TH.Syntax.Kind -> Language.Haskell.TH.Syntax.Kind -> Language.Haskell.TH.Syntax.Kind
  appKindT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Kind -> m Language.Haskell.TH.Syntax.Type
  appT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  appTypeE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Exp
  appsE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Exp] -> m Language.Haskell.TH.Syntax.Exp
  arithSeqE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Range -> m Language.Haskell.TH.Syntax.Exp
  arrowK :: Language.Haskell.TH.Syntax.Kind
  arrowT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type
  asP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Pat
  bang :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.SourceUnpackedness -> m Language.Haskell.TH.Syntax.SourceStrictness -> m Language.Haskell.TH.Syntax.Bang
  bangP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Pat
  bangType :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Bang -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.BangType
  bindS :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Stmt
  bndrInvis :: Language.Haskell.TH.Syntax.BndrVis
  bndrReq :: Language.Haskell.TH.Syntax.BndrVis
  bytesPrimL :: Language.Haskell.TH.Syntax.Bytes -> Language.Haskell.TH.Syntax.Lit
  cApi :: Language.Haskell.TH.Syntax.Callconv
  cCall :: Language.Haskell.TH.Syntax.Callconv
  caseE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> [m Language.Haskell.TH.Syntax.Match] -> m Language.Haskell.TH.Syntax.Exp
  charL :: GHC.Types.Char -> Language.Haskell.TH.Syntax.Lit
  charPrimL :: GHC.Types.Char -> Language.Haskell.TH.Syntax.Lit
  charTyLit :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Char -> m Language.Haskell.TH.Syntax.TyLit
  classD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Name -> [m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)] -> [Language.Haskell.TH.Syntax.FunDep] -> [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Dec
  classP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m Language.Haskell.TH.Syntax.Type] -> m Language.Haskell.TH.Syntax.Pred
  clause :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Pat] -> m Language.Haskell.TH.Syntax.Body -> [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Clause
  closedTypeFamilyD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)] -> m Language.Haskell.TH.Syntax.FamilyResultSig -> GHC.Maybe.Maybe InjectivityAnn -> [m Language.Haskell.TH.Syntax.TySynEqn] -> m Language.Haskell.TH.Syntax.Dec
  compE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Stmt] -> m Language.Haskell.TH.Syntax.Exp
  conE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Exp
  conK :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Kind
  conP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m Language.Haskell.TH.Syntax.Type] -> [m Language.Haskell.TH.Syntax.Pat] -> m Language.Haskell.TH.Syntax.Pat
  conT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type
  condE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  constraintK :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Kind
  cxt :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Pred] -> m Language.Haskell.TH.Syntax.Cxt
  dataD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Name -> [m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)] -> GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.Kind) -> [m Language.Haskell.TH.Syntax.Con] -> [m Language.Haskell.TH.Syntax.DerivClause] -> m Language.Haskell.TH.Syntax.Dec
  dataD_doc :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.Q (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)] -> GHC.Maybe.Maybe (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Kind) -> [(Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String])] -> [Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.DerivClause] -> GHC.Maybe.Maybe GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  dataFamilyD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)] -> GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.Kind) -> m Language.Haskell.TH.Syntax.Dec
  dataInstD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Cxt -> GHC.Maybe.Maybe [m (Language.Haskell.TH.Syntax.TyVarBndr ())] -> m Language.Haskell.TH.Syntax.Type -> GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.Kind) -> [m Language.Haskell.TH.Syntax.Con] -> [m Language.Haskell.TH.Syntax.DerivClause] -> m Language.Haskell.TH.Syntax.Dec
  dataInstD_doc :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Cxt -> GHC.Maybe.Maybe [Language.Haskell.TH.Syntax.Q (Language.Haskell.TH.Syntax.TyVarBndr ())] -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type -> GHC.Maybe.Maybe (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Kind) -> [(Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String])] -> [Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.DerivClause] -> GHC.Maybe.Maybe GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  defaultD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Type] -> m Language.Haskell.TH.Syntax.Dec
  defaultSigD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  derivClause :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.DerivStrategy) -> [m Language.Haskell.TH.Syntax.Pred] -> m Language.Haskell.TH.Syntax.DerivClause
  doE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Maybe.Maybe Language.Haskell.TH.Syntax.ModName -> [m Language.Haskell.TH.Syntax.Stmt] -> m Language.Haskell.TH.Syntax.Exp
  docCons :: (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String]) -> Language.Haskell.TH.Syntax.Q ()
  doublePrimL :: GHC.Real.Rational -> Language.Haskell.TH.Syntax.Lit
  dyn :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> m Language.Haskell.TH.Syntax.Exp
  equalP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Pred
  equalityT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type
  explBidir :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Clause] -> m Language.Haskell.TH.Syntax.PatSynDir
  fieldExp :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Exp -> m (Language.Haskell.TH.Syntax.Name, Language.Haskell.TH.Syntax.Exp)
  fieldPat :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.FieldPat
  floatPrimL :: GHC.Real.Rational -> Language.Haskell.TH.Syntax.Lit
  forImpD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Callconv -> Language.Haskell.TH.Syntax.Safety -> GHC.Base.String -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  forallC :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.Specificity)] -> m Language.Haskell.TH.Syntax.Cxt -> m Language.Haskell.TH.Syntax.Con -> m Language.Haskell.TH.Syntax.Con
  forallT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.Specificity)] -> m Language.Haskell.TH.Syntax.Cxt -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  forallVisT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m (Language.Haskell.TH.Syntax.TyVarBndr ())] -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  fromE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  fromR :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Range
  fromThenE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  fromThenR :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Range
  fromThenToE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  fromThenToR :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Range
  fromToE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  fromToR :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Range
  funD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m Language.Haskell.TH.Syntax.Clause] -> m Language.Haskell.TH.Syntax.Dec
  funD_doc :: Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Clause] -> GHC.Maybe.Maybe GHC.Base.String -> [GHC.Maybe.Maybe GHC.Base.String] -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  funDep :: [Language.Haskell.TH.Syntax.Name] -> [Language.Haskell.TH.Syntax.Name] -> Language.Haskell.TH.Syntax.FunDep
  gadtC :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [Language.Haskell.TH.Syntax.Name] -> [m Language.Haskell.TH.Syntax.StrictType] -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Con
  getFieldE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> GHC.Base.String -> m Language.Haskell.TH.Syntax.Exp
  guardedB :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m (Language.Haskell.TH.Syntax.Guard, Language.Haskell.TH.Syntax.Exp)] -> m Language.Haskell.TH.Syntax.Body
  implBidir :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.PatSynDir
  implicitParamBindD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Dec
  implicitParamT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  implicitParamVarE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> m Language.Haskell.TH.Syntax.Exp
  inferR :: Role
  inferredSpec :: Language.Haskell.TH.Syntax.Specificity
  infixApp :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  infixC :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m (Language.Haskell.TH.Syntax.Bang, Language.Haskell.TH.Syntax.Type) -> Language.Haskell.TH.Syntax.Name -> m (Language.Haskell.TH.Syntax.Bang, Language.Haskell.TH.Syntax.Type) -> m Language.Haskell.TH.Syntax.Con
  infixE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.Exp) -> m Language.Haskell.TH.Syntax.Exp -> GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.Exp) -> m Language.Haskell.TH.Syntax.Exp
  infixLD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Int -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Dec
  infixND :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Int -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Dec
  infixP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Pat
  infixPatSyn :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.PatSynArgs
  infixRD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Int -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Dec
  infixT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  injectivityAnn :: Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.Name] -> InjectivityAnn
  instanceD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Cxt -> m Language.Haskell.TH.Syntax.Type -> [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Dec
  instanceWithOverlapD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Overlap -> m Language.Haskell.TH.Syntax.Cxt -> m Language.Haskell.TH.Syntax.Type -> [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Dec
  intPrimL :: GHC.Num.Integer.Integer -> Language.Haskell.TH.Syntax.Lit
  integerL :: GHC.Num.Integer.Integer -> Language.Haskell.TH.Syntax.Lit
  interruptible :: Language.Haskell.TH.Syntax.Safety
  isStrict :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Strict
  javaScript :: Language.Haskell.TH.Syntax.Callconv
  kiSigD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Kind -> m Language.Haskell.TH.Syntax.Dec
  kindSig :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Kind -> m Language.Haskell.TH.Syntax.FamilyResultSig
  kindedBndrTV :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.BndrVis -> m Language.Haskell.TH.Syntax.Kind -> m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)
  kindedInvisTV :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Specificity -> m Language.Haskell.TH.Syntax.Kind -> m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.Specificity)
  kindedTV :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Kind -> m (Language.Haskell.TH.Syntax.TyVarBndr ())
  labelE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> m Language.Haskell.TH.Syntax.Exp
  lam1E :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  lamCaseE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Match] -> m Language.Haskell.TH.Syntax.Exp
  lamCasesE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Clause] -> m Language.Haskell.TH.Syntax.Exp
  lamE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Pat] -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  letE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  letS :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Stmt
  listE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Exp] -> m Language.Haskell.TH.Syntax.Exp
  listK :: Language.Haskell.TH.Syntax.Kind
  listP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Pat] -> m Language.Haskell.TH.Syntax.Pat
  listT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type
  litE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Lit -> m Language.Haskell.TH.Syntax.Exp
  litP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Lit -> m Language.Haskell.TH.Syntax.Pat
  litT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.TyLit -> m Language.Haskell.TH.Syntax.Type
  match :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Body -> [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Match
  mdoE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Maybe.Maybe Language.Haskell.TH.Syntax.ModName -> [m Language.Haskell.TH.Syntax.Stmt] -> m Language.Haskell.TH.Syntax.Exp
  moduleAnnotation :: Language.Haskell.TH.Syntax.AnnTarget
  mulArrowT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type
  multiIfE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m (Language.Haskell.TH.Syntax.Guard, Language.Haskell.TH.Syntax.Exp)] -> m Language.Haskell.TH.Syntax.Exp
  newtypeD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Name -> [m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)] -> GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.Kind) -> m Language.Haskell.TH.Syntax.Con -> [m Language.Haskell.TH.Syntax.DerivClause] -> m Language.Haskell.TH.Syntax.Dec
  newtypeD_doc :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.Q (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)] -> GHC.Maybe.Maybe (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Kind) -> (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String]) -> [Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.DerivClause] -> GHC.Maybe.Maybe GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  newtypeInstD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Cxt -> GHC.Maybe.Maybe [m (Language.Haskell.TH.Syntax.TyVarBndr ())] -> m Language.Haskell.TH.Syntax.Type -> GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.Kind) -> m Language.Haskell.TH.Syntax.Con -> [m Language.Haskell.TH.Syntax.DerivClause] -> m Language.Haskell.TH.Syntax.Dec
  newtypeInstD_doc :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Cxt -> GHC.Maybe.Maybe [Language.Haskell.TH.Syntax.Q (Language.Haskell.TH.Syntax.TyVarBndr ())] -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type -> GHC.Maybe.Maybe (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Kind) -> (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String]) -> [Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.DerivClause] -> GHC.Maybe.Maybe GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  newtypeStrategy :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.DerivStrategy
  noBindS :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Stmt
  noSig :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.FamilyResultSig
  noSourceStrictness :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.SourceStrictness
  noSourceUnpackedness :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.SourceUnpackedness
  nominalR :: Role
  normalB :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Body
  normalC :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m Language.Haskell.TH.Syntax.BangType] -> m Language.Haskell.TH.Syntax.Con
  normalG :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Guard
  normalGE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m (Language.Haskell.TH.Syntax.Guard, Language.Haskell.TH.Syntax.Exp)
  notStrict :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Strict
  numTyLit :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Num.Integer.Integer -> m Language.Haskell.TH.Syntax.TyLit
  openTypeFamilyD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)] -> m Language.Haskell.TH.Syntax.FamilyResultSig -> GHC.Maybe.Maybe InjectivityAnn -> m Language.Haskell.TH.Syntax.Dec
  parS :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [[m Language.Haskell.TH.Syntax.Stmt]] -> m Language.Haskell.TH.Syntax.Stmt
  parensE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  parensP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Pat
  parensT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  patG :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Stmt] -> m Language.Haskell.TH.Syntax.Guard
  patGE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Stmt] -> m Language.Haskell.TH.Syntax.Exp -> m (Language.Haskell.TH.Syntax.Guard, Language.Haskell.TH.Syntax.Exp)
  patSynD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.PatSynArgs -> m Language.Haskell.TH.Syntax.PatSynDir -> m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Dec
  patSynD_doc :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.PatSynArgs -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.PatSynDir -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Pat -> GHC.Maybe.Maybe GHC.Base.String -> [GHC.Maybe.Maybe GHC.Base.String] -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  patSynSigD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  phantomR :: Role
  plainBndrTV :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.BndrVis -> m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)
  plainInvisTV :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Specificity -> m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.Specificity)
  plainTV :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m (Language.Haskell.TH.Syntax.TyVarBndr ())
  pragAnnD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.AnnTarget -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Dec
  pragCompleteD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [Language.Haskell.TH.Syntax.Name] -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Dec
  pragInlD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Inline -> Language.Haskell.TH.Syntax.RuleMatch -> Language.Haskell.TH.Syntax.Phases -> m Language.Haskell.TH.Syntax.Dec
  pragLineD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Int -> GHC.Base.String -> m Language.Haskell.TH.Syntax.Dec
  pragOpaqueD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Dec
  pragRuleD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> GHC.Maybe.Maybe [m (Language.Haskell.TH.Syntax.TyVarBndr ())] -> [m Language.Haskell.TH.Syntax.RuleBndr] -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> Language.Haskell.TH.Syntax.Phases -> m Language.Haskell.TH.Syntax.Dec
  pragSpecD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.Syntax.Phases -> m Language.Haskell.TH.Syntax.Dec
  pragSpecInlD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.Syntax.Inline -> Language.Haskell.TH.Syntax.Phases -> m Language.Haskell.TH.Syntax.Dec
  pragSpecInstD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  prefixPatSyn :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [Language.Haskell.TH.Syntax.Name] -> m Language.Haskell.TH.Syntax.PatSynArgs
  prim :: Language.Haskell.TH.Syntax.Callconv
  projectionE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.NonEmpty GHC.Base.String -> m Language.Haskell.TH.Syntax.Exp
  promotedConsT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type
  promotedInfixT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  promotedNilT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type
  promotedT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type
  promotedTupleT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Int -> m Language.Haskell.TH.Syntax.Type
  promotedUInfixT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  rationalL :: GHC.Real.Rational -> Language.Haskell.TH.Syntax.Lit
  recC :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m Language.Haskell.TH.Syntax.VarBangType] -> m Language.Haskell.TH.Syntax.Con
  recConE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m (Language.Haskell.TH.Syntax.Name, Language.Haskell.TH.Syntax.Exp)] -> m Language.Haskell.TH.Syntax.Exp
  recGadtC :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [Language.Haskell.TH.Syntax.Name] -> [m Language.Haskell.TH.Syntax.VarStrictType] -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Con
  recP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m Language.Haskell.TH.Syntax.FieldPat] -> m Language.Haskell.TH.Syntax.Pat
  recS :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Stmt] -> m Language.Haskell.TH.Syntax.Stmt
  recUpdE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> [m (Language.Haskell.TH.Syntax.Name, Language.Haskell.TH.Syntax.Exp)] -> m Language.Haskell.TH.Syntax.Exp
  recordPatSyn :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [Language.Haskell.TH.Syntax.Name] -> m Language.Haskell.TH.Syntax.PatSynArgs
  representationalR :: Role
  roleAnnotD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [Role] -> m Language.Haskell.TH.Syntax.Dec
  ruleVar :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.RuleBndr
  safe :: Language.Haskell.TH.Syntax.Safety
  sectionL :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  sectionR :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  sigD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  sigE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Exp
  sigP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Pat
  sigT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Kind -> m Language.Haskell.TH.Syntax.Type
  sourceLazy :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.SourceStrictness
  sourceNoUnpack :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.SourceUnpackedness
  sourceStrict :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.SourceStrictness
  sourceUnpack :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.SourceUnpackedness
  specifiedSpec :: Language.Haskell.TH.Syntax.Specificity
  standaloneDerivD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Cxt -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  standaloneDerivWithStrategyD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.DerivStrategy) -> m Language.Haskell.TH.Syntax.Cxt -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  starK :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Kind
  staticE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  stdCall :: Language.Haskell.TH.Syntax.Callconv
  stockStrategy :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.DerivStrategy
  strTyLit :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> m Language.Haskell.TH.Syntax.TyLit
  strictType :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Strict -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.StrictType
  stringE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Base.String -> m Language.Haskell.TH.Syntax.Exp
  stringL :: GHC.Base.String -> Language.Haskell.TH.Syntax.Lit
  stringPrimL :: [GHC.Word.Word8] -> Language.Haskell.TH.Syntax.Lit
  thisModule :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Module
  tildeP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Pat
  tupE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.Exp)] -> m Language.Haskell.TH.Syntax.Exp
  tupP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Pat] -> m Language.Haskell.TH.Syntax.Pat
  tupleK :: GHC.Types.Int -> Language.Haskell.TH.Syntax.Kind
  tupleT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Int -> m Language.Haskell.TH.Syntax.Type
  tySynD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)] -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Dec
  tySynEqn :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Maybe.Maybe [m (Language.Haskell.TH.Syntax.TyVarBndr ())] -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.TySynEqn
  tySynInstD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.TySynEqn -> m Language.Haskell.TH.Syntax.Dec
  tyVarSig :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m (Language.Haskell.TH.Syntax.TyVarBndr ()) -> m Language.Haskell.TH.Syntax.FamilyResultSig
  typeAnnotation :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.AnnTarget
  typeDataD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> [m (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)] -> GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.Kind) -> [m Language.Haskell.TH.Syntax.Con] -> m Language.Haskell.TH.Syntax.Dec
  typeDataD_doc :: Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.Q (Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.BndrVis)] -> GHC.Maybe.Maybe (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Kind) -> [(Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Con, GHC.Maybe.Maybe GHC.Base.String, [GHC.Maybe.Maybe GHC.Base.String])] -> GHC.Maybe.Maybe GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  typedBracketE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  typedRuleVar :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.RuleBndr
  typedSpliceE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  uInfixE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Exp
  uInfixP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Pat
  uInfixT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.Type
  unboundVarE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Exp
  unboxedSumE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> Language.Haskell.TH.Syntax.SumAlt -> Language.Haskell.TH.Syntax.SumArity -> m Language.Haskell.TH.Syntax.Exp
  unboxedSumP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> Language.Haskell.TH.Syntax.SumAlt -> Language.Haskell.TH.Syntax.SumArity -> m Language.Haskell.TH.Syntax.Pat
  unboxedSumT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.SumArity -> m Language.Haskell.TH.Syntax.Type
  unboxedTupE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.Exp)] -> m Language.Haskell.TH.Syntax.Exp
  unboxedTupP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => [m Language.Haskell.TH.Syntax.Pat] -> m Language.Haskell.TH.Syntax.Pat
  unboxedTupleT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => GHC.Types.Int -> m Language.Haskell.TH.Syntax.Type
  unidir :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.PatSynDir
  unpacked :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Strict
  unsafe :: Language.Haskell.TH.Syntax.Safety
  valD :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Body -> [m Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Dec
  valueAnnotation :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.AnnTarget
  varBangType :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.BangType -> m Language.Haskell.TH.Syntax.VarBangType
  varE :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Exp
  varK :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Kind
  varP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Pat
  varStrictType :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.StrictType -> m Language.Haskell.TH.Syntax.VarStrictType
  varT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => Language.Haskell.TH.Syntax.Name -> m Language.Haskell.TH.Syntax.Type
  viaStrategy :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type -> m Language.Haskell.TH.Syntax.DerivStrategy
  viewP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Exp -> m Language.Haskell.TH.Syntax.Pat -> m Language.Haskell.TH.Syntax.Pat
  wildCardT :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Type
  wildP :: forall (m :: * -> *). Language.Haskell.TH.Syntax.Quote m => m Language.Haskell.TH.Syntax.Pat
  withDecDoc :: GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Dec
  withDecsDoc :: GHC.Base.String -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec] -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  wordPrimL :: GHC.Num.Integer.Integer -> Language.Haskell.TH.Syntax.Lit

module Language.Haskell.TH.Ppr where
  -- Safety: Safe
  type ForallVisFlag :: *
  data ForallVisFlag = ForallVis | ForallInvis
  type Ppr :: * -> Constraint
  class Ppr a where
    ppr :: a -> Language.Haskell.TH.PprLib.Doc
    ppr_list :: [a] -> Language.Haskell.TH.PprLib.Doc
    {-# MINIMAL ppr #-}
  type PprFlag :: * -> Constraint
  class PprFlag flag where
    pprTyVarBndr :: Language.Haskell.TH.Syntax.TyVarBndr flag -> Language.Haskell.TH.PprLib.Doc
    {-# MINIMAL pprTyVarBndr #-}
  type Precedence :: *
  type Precedence = GHC.Types.Int
  type TypeArg :: *
  data TypeArg = TANormal Language.Haskell.TH.Syntax.Type | TyArg Language.Haskell.TH.Syntax.Kind
  appPrec :: Precedence
  bar :: Language.Haskell.TH.PprLib.Doc
  bytesToString :: [GHC.Word.Word8] -> GHC.Base.String
  commaSep :: forall a. Ppr a => [a] -> Language.Haskell.TH.PprLib.Doc
  commaSepApplied :: [Language.Haskell.TH.Syntax.Name] -> Language.Haskell.TH.PprLib.Doc
  commaSepWith :: forall a. (a -> Language.Haskell.TH.PprLib.Doc) -> [a] -> Language.Haskell.TH.PprLib.Doc
  fromTANormal :: TypeArg -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Type
  funPrec :: Precedence
  hashParens :: Language.Haskell.TH.PprLib.Doc -> Language.Haskell.TH.PprLib.Doc
  isStarT :: Language.Haskell.TH.Syntax.Type -> GHC.Types.Bool
  isSymOcc :: Language.Haskell.TH.Syntax.Name -> GHC.Types.Bool
  nestDepth :: GHC.Types.Int
  noPrec :: Precedence
  opPrec :: Precedence
  parensIf :: GHC.Types.Bool -> Language.Haskell.TH.PprLib.Doc -> Language.Haskell.TH.PprLib.Doc
  pprBangType :: Language.Haskell.TH.Syntax.BangType -> Language.Haskell.TH.PprLib.Doc
  pprBndrVis :: Language.Haskell.TH.Syntax.BndrVis -> Language.Haskell.TH.PprLib.Doc -> Language.Haskell.TH.PprLib.Doc
  pprBody :: GHC.Types.Bool -> Language.Haskell.TH.Syntax.Body -> Language.Haskell.TH.PprLib.Doc
  pprClause :: GHC.Types.Bool -> Language.Haskell.TH.Syntax.Clause -> Language.Haskell.TH.PprLib.Doc
  pprCxt :: Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.PprLib.Doc
  pprExp :: Precedence -> Language.Haskell.TH.Syntax.Exp -> Language.Haskell.TH.PprLib.Doc
  pprFields :: [(Language.Haskell.TH.Syntax.Name, Language.Haskell.TH.Syntax.Exp)] -> Language.Haskell.TH.PprLib.Doc
  pprFixity :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Fixity -> Language.Haskell.TH.PprLib.Doc
  pprForall :: [Language.Haskell.TH.Syntax.TyVarBndr Language.Haskell.TH.Syntax.Specificity] -> Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.PprLib.Doc
  pprForall' :: forall flag. PprFlag flag => ForallVisFlag -> [Language.Haskell.TH.Syntax.TyVarBndr flag] -> Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.PprLib.Doc
  pprForallVis :: [Language.Haskell.TH.Syntax.TyVarBndr ()] -> Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.PprLib.Doc
  pprFunArgType :: Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.PprLib.Doc
  pprGadtRHS :: [(Language.Haskell.TH.Syntax.Strict, Language.Haskell.TH.Syntax.Type)] -> Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.PprLib.Doc
  pprGuarded :: Language.Haskell.TH.PprLib.Doc -> (Language.Haskell.TH.Syntax.Guard, Language.Haskell.TH.Syntax.Exp) -> Language.Haskell.TH.PprLib.Doc
  pprInfixExp :: Language.Haskell.TH.Syntax.Exp -> Language.Haskell.TH.PprLib.Doc
  pprInfixT :: Precedence -> Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.PprLib.Doc
  pprLit :: Precedence -> Language.Haskell.TH.Syntax.Lit -> Language.Haskell.TH.PprLib.Doc
  pprMatchPat :: Language.Haskell.TH.Syntax.Pat -> Language.Haskell.TH.PprLib.Doc
  pprMaybeExp :: Precedence -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Exp -> Language.Haskell.TH.PprLib.Doc
  pprParendType :: Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.PprLib.Doc
  pprParendTypeArg :: TypeArg -> Language.Haskell.TH.PprLib.Doc
  pprPat :: Precedence -> Language.Haskell.TH.Syntax.Pat -> Language.Haskell.TH.PprLib.Doc
  pprPatSynSig :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.PatSynType -> Language.Haskell.TH.PprLib.Doc
  pprPatSynType :: Language.Haskell.TH.Syntax.PatSynType -> Language.Haskell.TH.PprLib.Doc
  pprPrefixOcc :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.PprLib.Doc
  pprRecFields :: [(Language.Haskell.TH.Syntax.Name, Language.Haskell.TH.Syntax.Strict, Language.Haskell.TH.Syntax.Type)] -> Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.PprLib.Doc
  pprStrictType :: (Language.Haskell.TH.Syntax.Strict, Language.Haskell.TH.Syntax.Type) -> Language.Haskell.TH.PprLib.Doc
  pprString :: GHC.Base.String -> Language.Haskell.TH.PprLib.Doc
  pprTyApp :: Precedence -> (Language.Haskell.TH.Syntax.Type, [TypeArg]) -> Language.Haskell.TH.PprLib.Doc
  pprTyLit :: Language.Haskell.TH.Syntax.TyLit -> Language.Haskell.TH.PprLib.Doc
  pprType :: Precedence -> Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.PprLib.Doc
  pprVarBangType :: Language.Haskell.TH.Syntax.VarBangType -> Language.Haskell.TH.PprLib.Doc
  pprVarStrictType :: (Language.Haskell.TH.Syntax.Name, Language.Haskell.TH.Syntax.Strict, Language.Haskell.TH.Syntax.Type) -> Language.Haskell.TH.PprLib.Doc
  ppr_bndrs :: forall flag. PprFlag flag => GHC.Maybe.Maybe [Language.Haskell.TH.Syntax.TyVarBndr flag] -> Language.Haskell.TH.PprLib.Doc
  ppr_cxt_preds :: Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.PprLib.Doc
  ppr_data :: Language.Haskell.TH.PprLib.Doc -> Language.Haskell.TH.Syntax.Cxt -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.PprLib.Doc -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Kind -> [Language.Haskell.TH.Syntax.Con] -> [Language.Haskell.TH.Syntax.DerivClause] -> Language.Haskell.TH.PprLib.Doc
  ppr_dec :: GHC.Types.Bool -> Language.Haskell.TH.Syntax.Dec -> Language.Haskell.TH.PprLib.Doc
  ppr_deriv_clause :: Language.Haskell.TH.Syntax.DerivClause -> Language.Haskell.TH.PprLib.Doc
  ppr_deriv_strategy :: Language.Haskell.TH.Syntax.DerivStrategy -> Language.Haskell.TH.PprLib.Doc
  ppr_newtype :: Language.Haskell.TH.PprLib.Doc -> Language.Haskell.TH.Syntax.Cxt -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.PprLib.Doc -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Kind -> Language.Haskell.TH.Syntax.Con -> [Language.Haskell.TH.Syntax.DerivClause] -> Language.Haskell.TH.PprLib.Doc
  ppr_overlap :: Language.Haskell.TH.Syntax.Overlap -> Language.Haskell.TH.PprLib.Doc
  ppr_sig :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.PprLib.Doc
  ppr_tf_head :: Language.Haskell.TH.Syntax.TypeFamilyHead -> Language.Haskell.TH.PprLib.Doc
  ppr_tySyn :: Language.Haskell.TH.PprLib.Doc -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.PprLib.Doc -> Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.PprLib.Doc
  ppr_type_data :: Language.Haskell.TH.PprLib.Doc -> Language.Haskell.TH.Syntax.Cxt -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.PprLib.Doc -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Kind -> [Language.Haskell.TH.Syntax.Con] -> [Language.Haskell.TH.Syntax.DerivClause] -> Language.Haskell.TH.PprLib.Doc
  ppr_typedef :: GHC.Base.String -> Language.Haskell.TH.PprLib.Doc -> Language.Haskell.TH.Syntax.Cxt -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.PprLib.Doc -> GHC.Maybe.Maybe Language.Haskell.TH.Syntax.Kind -> [Language.Haskell.TH.Syntax.Con] -> [Language.Haskell.TH.Syntax.DerivClause] -> Language.Haskell.TH.PprLib.Doc
  pprint :: forall a. Ppr a => a -> GHC.Base.String
  qualPrec :: Precedence
  quoteParens :: Language.Haskell.TH.PprLib.Doc -> Language.Haskell.TH.PprLib.Doc
  semiSep :: forall a. Ppr a => [a] -> Language.Haskell.TH.PprLib.Doc
  semiSepWith :: forall a. (a -> Language.Haskell.TH.PprLib.Doc) -> [a] -> Language.Haskell.TH.PprLib.Doc
  sepWith :: forall a. Language.Haskell.TH.PprLib.Doc -> (a -> Language.Haskell.TH.PprLib.Doc) -> [a] -> Language.Haskell.TH.PprLib.Doc
  showtextl :: forall a. GHC.Show.Show a => a -> Language.Haskell.TH.PprLib.Doc
  sigPrec :: Precedence
  split :: Language.Haskell.TH.Syntax.Type -> (Language.Haskell.TH.Syntax.Type, [TypeArg])
  unboxedSumBars :: Language.Haskell.TH.PprLib.Doc -> Language.Haskell.TH.Syntax.SumAlt -> Language.Haskell.TH.Syntax.SumArity -> Language.Haskell.TH.PprLib.Doc
  unopPrec :: Precedence
  where_clause :: [Language.Haskell.TH.Syntax.Dec] -> Language.Haskell.TH.PprLib.Doc

module Language.Haskell.TH.PprLib where
  -- Safety: Safe
  ($$) :: Doc -> Doc -> Doc
  ($+$) :: Doc -> Doc -> Doc
  (<+>) :: Doc -> Doc -> Doc
  (<>) :: Doc -> Doc -> Doc
  type Doc :: *
  type Doc = PprM Text.PrettyPrint.HughesPJ.Doc
  type PprM :: * -> *
  data PprM a = ...
  arrow :: Doc
  braces :: Doc -> Doc
  brackets :: Doc -> Doc
  cat :: [Doc] -> Doc
  char :: GHC.Types.Char -> Doc
  colon :: Doc
  comma :: Doc
  dcolon :: Doc
  double :: GHC.Types.Double -> Doc
  doubleQuotes :: Doc -> Doc
  empty :: Doc
  equals :: Doc
  fcat :: [Doc] -> Doc
  float :: GHC.Types.Float -> Doc
  fsep :: [Doc] -> Doc
  hang :: Doc -> GHC.Types.Int -> Doc -> Doc
  hcat :: [Doc] -> Doc
  hsep :: [Doc] -> Doc
  int :: GHC.Types.Int -> Doc
  integer :: GHC.Num.Integer.Integer -> Doc
  isEmpty :: Doc -> PprM GHC.Types.Bool
  lbrace :: Doc
  lbrack :: Doc
  lparen :: Doc
  nest :: GHC.Types.Int -> Doc -> Doc
  parens :: Doc -> Doc
  pprName :: Language.Haskell.TH.Syntax.Name -> Doc
  pprName' :: Language.Haskell.TH.Syntax.NameIs -> Language.Haskell.TH.Syntax.Name -> Doc
  ptext :: GHC.Base.String -> Doc
  punctuate :: Doc -> [Doc] -> [Doc]
  quotes :: Doc -> Doc
  rational :: GHC.Real.Rational -> Doc
  rbrace :: Doc
  rbrack :: Doc
  rparen :: Doc
  semi :: Doc
  sep :: [Doc] -> Doc
  space :: Doc
  text :: GHC.Base.String -> Doc
  to_HPJ_Doc :: Doc -> Text.PrettyPrint.HughesPJ.Doc
  vcat :: [Doc] -> Doc

module Language.Haskell.TH.Quote where
  -- Safety: Safe
  type QuasiQuoter :: *
  data QuasiQuoter = QuasiQuoter {quoteExp :: GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp, quotePat :: GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Pat, quoteType :: GHC.Base.String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type, quoteDec :: GHC.Base.String -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]}
  dataToExpQ :: forall (m :: * -> *) a. (Language.Haskell.TH.Syntax.Quote m, Data.Data.Data a) => (forall b. Data.Data.Data b => b -> GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.Exp)) -> a -> m Language.Haskell.TH.Syntax.Exp
  dataToPatQ :: forall (m :: * -> *) a. (Language.Haskell.TH.Syntax.Quote m, Data.Data.Data a) => (forall b. Data.Data.Data b => b -> GHC.Maybe.Maybe (m Language.Haskell.TH.Syntax.Pat)) -> a -> m Language.Haskell.TH.Syntax.Pat
  dataToQa :: forall (m :: * -> *) a k q. (Language.Haskell.TH.Syntax.Quote m, Data.Data.Data a) => (Language.Haskell.TH.Syntax.Name -> k) -> (Language.Haskell.TH.Syntax.Lit -> m q) -> (k -> [m q] -> m q) -> (forall b. Data.Data.Data b => b -> GHC.Maybe.Maybe (m q)) -> a -> m q
  quoteFile :: QuasiQuoter -> QuasiQuoter

module Language.Haskell.TH.Syntax where
  -- Safety: Trustworthy
  type AnnLookup :: *
  data AnnLookup = AnnLookupModule Module | AnnLookupName Name
  type AnnTarget :: *
  data AnnTarget = ModuleAnnotation | TypeAnnotation Name | ValueAnnotation Name
  type Arity :: *
  type Arity = GHC.Types.Int
  type Bang :: *
  data Bang = Bang SourceUnpackedness SourceStrictness
  type BangType :: *
  type BangType = (Bang, Type)
  type BndrVis :: *
  data BndrVis = BndrReq | BndrInvis
  type Body :: *
  data Body = GuardedB [(Guard, Exp)] | NormalB Exp
  type Bytes :: *
  data Bytes = Bytes {bytesPtr :: GHC.ForeignPtr.ForeignPtr GHC.Word.Word8, bytesOffset :: GHC.Types.Word, bytesSize :: GHC.Types.Word}
  type Callconv :: *
  data Callconv = CCall | StdCall | CApi | Prim | JavaScript
  type CharPos :: *
  type CharPos = (GHC.Types.Int, GHC.Types.Int)
  type Clause :: *
  data Clause = Clause [Pat] Body [Dec]
  type role Code representational nominal
  type Code :: (* -> *) -> forall (r :: GHC.Types.RuntimeRep). TYPE r -> *
  newtype Code m a = Code {examineCode :: m (TExp a)}
  type Con :: *
  data Con = NormalC Name [BangType] | RecC Name [VarBangType] | InfixC BangType Name BangType | ForallC [TyVarBndr Specificity] Cxt Con | GadtC [Name] [BangType] Type | RecGadtC [Name] [VarBangType] Type
  type Cxt :: *
  type Cxt = [Pred]
  type Dec :: *
  data Dec
    = FunD Name [Clause]
    | ValD Pat Body [Dec]
    | DataD Cxt Name [TyVarBndr BndrVis] (GHC.Maybe.Maybe Kind) [Con] [DerivClause]
    | NewtypeD Cxt Name [TyVarBndr BndrVis] (GHC.Maybe.Maybe Kind) Con [DerivClause]
    | TypeDataD Name [TyVarBndr BndrVis] (GHC.Maybe.Maybe Kind) [Con]
    | TySynD Name [TyVarBndr BndrVis] Type
    | ClassD Cxt Name [TyVarBndr BndrVis] [FunDep] [Dec]
    | InstanceD (GHC.Maybe.Maybe Overlap) Cxt Type [Dec]
    | SigD Name Type
    | KiSigD Name Kind
    | ForeignD Foreign
    | InfixD Fixity Name
    | DefaultD [Type]
    | PragmaD Pragma
    | DataFamilyD Name [TyVarBndr BndrVis] (GHC.Maybe.Maybe Kind)
    | DataInstD Cxt (GHC.Maybe.Maybe [TyVarBndr ()]) Type (GHC.Maybe.Maybe Kind) [Con] [DerivClause]
    | NewtypeInstD Cxt (GHC.Maybe.Maybe [TyVarBndr ()]) Type (GHC.Maybe.Maybe Kind) Con [DerivClause]
    | TySynInstD TySynEqn
    | OpenTypeFamilyD TypeFamilyHead
    | ClosedTypeFamilyD TypeFamilyHead [TySynEqn]
    | RoleAnnotD Name [Role]
    | StandaloneDerivD (GHC.Maybe.Maybe DerivStrategy) Cxt Type
    | DefaultSigD Name Type
    | PatSynD Name PatSynArgs PatSynDir Pat
    | PatSynSigD Name PatSynType
    | ImplicitParamBindD GHC.Base.String Exp
  type DecidedStrictness :: *
  data DecidedStrictness = DecidedLazy | DecidedStrict | DecidedUnpack
  type DerivClause :: *
  data DerivClause = DerivClause (GHC.Maybe.Maybe DerivStrategy) Cxt
  type DerivStrategy :: *
  data DerivStrategy = StockStrategy | AnyclassStrategy | NewtypeStrategy | ViaStrategy Type
  type DocLoc :: *
  data DocLoc = ModuleDoc | DeclDoc Name | ArgDoc Name GHC.Types.Int | InstDoc Type
  type Exp :: *
  data Exp
    = VarE Name
    | ConE Name
    | LitE Lit
    | AppE Exp Exp
    | AppTypeE Exp Type
    | InfixE (GHC.Maybe.Maybe Exp) Exp (GHC.Maybe.Maybe Exp)
    | UInfixE Exp Exp Exp
    | ParensE Exp
    | LamE [Pat] Exp
    | LamCaseE [Match]
    | LamCasesE [Clause]
    | TupE [GHC.Maybe.Maybe Exp]
    | UnboxedTupE [GHC.Maybe.Maybe Exp]
    | UnboxedSumE Exp SumAlt SumArity
    | CondE Exp Exp Exp
    | MultiIfE [(Guard, Exp)]
    | LetE [Dec] Exp
    | CaseE Exp [Match]
    | DoE (GHC.Maybe.Maybe ModName) [Stmt]
    | MDoE (GHC.Maybe.Maybe ModName) [Stmt]
    | CompE [Stmt]
    | ArithSeqE Range
    | ListE [Exp]
    | SigE Exp Type
    | RecConE Name [FieldExp]
    | RecUpdE Exp [FieldExp]
    | StaticE Exp
    | UnboundVarE Name
    | LabelE GHC.Base.String
    | ImplicitParamVarE GHC.Base.String
    | GetFieldE Exp GHC.Base.String
    | ProjectionE (GHC.Base.NonEmpty GHC.Base.String)
    | TypedBracketE Exp
    | TypedSpliceE Exp
  type Extension :: *
  data Extension
    = Cpp
    | OverlappingInstances
    | UndecidableInstances
    | IncoherentInstances
    | UndecidableSuperClasses
    | MonomorphismRestriction
    | MonoLocalBinds
    | DeepSubsumption
    | RelaxedPolyRec
    | ExtendedDefaultRules
    | ForeignFunctionInterface
    | UnliftedFFITypes
    | InterruptibleFFI
    | CApiFFI
    | GHCForeignImportPrim
    | JavaScriptFFI
    | ParallelArrays
    | Arrows
    | TemplateHaskell
    | TemplateHaskellQuotes
    | QualifiedDo
    | QuasiQuotes
    | ImplicitParams
    | ImplicitPrelude
    | ScopedTypeVariables
    | AllowAmbiguousTypes
    | UnboxedTuples
    | UnboxedSums
    | UnliftedNewtypes
    | UnliftedDatatypes
    | BangPatterns
    | TypeFamilies
    | TypeFamilyDependencies
    | TypeInType
    | OverloadedStrings
    | OverloadedLists
    | NumDecimals
    | DisambiguateRecordFields
    | RecordWildCards
    | NamedFieldPuns
    | ViewPatterns
    | GADTs
    | GADTSyntax
    | NPlusKPatterns
    | DoAndIfThenElse
    | BlockArguments
    | RebindableSyntax
    | ConstraintKinds
    | PolyKinds
    | DataKinds
    | TypeData
    | InstanceSigs
    | ApplicativeDo
    | LinearTypes
    | StandaloneDeriving
    | DeriveDataTypeable
    | AutoDeriveTypeable
    | DeriveFunctor
    | DeriveTraversable
    | DeriveFoldable
    | DeriveGeneric
    | DefaultSignatures
    | DeriveAnyClass
    | DeriveLift
    | DerivingStrategies
    | DerivingVia
    | TypeSynonymInstances
    | FlexibleContexts
    | FlexibleInstances
    | ConstrainedClassMethods
    | MultiParamTypeClasses
    | NullaryTypeClasses
    | FunctionalDependencies
    | UnicodeSyntax
    | ExistentialQuantification
    | MagicHash
    | EmptyDataDecls
    | KindSignatures
    | RoleAnnotations
    | ParallelListComp
    | TransformListComp
    | MonadComprehensions
    | GeneralizedNewtypeDeriving
    | RecursiveDo
    | PostfixOperators
    | TupleSections
    | PatternGuards
    | LiberalTypeSynonyms
    | RankNTypes
    | ImpredicativeTypes
    | TypeOperators
    | ExplicitNamespaces
    | PackageImports
    | ExplicitForAll
    | AlternativeLayoutRule
    | AlternativeLayoutRuleTransitional
    | DatatypeContexts
    | NondecreasingIndentation
    | RelaxedLayout
    | TraditionalRecordSyntax
    | LambdaCase
    | MultiWayIf
    | BinaryLiterals
    | NegativeLiterals
    | HexFloatLiterals
    | DuplicateRecordFields
    | OverloadedLabels
    | EmptyCase
    | PatternSynonyms
    | PartialTypeSignatures
    | NamedWildCards
    | StaticPointers
    | TypeApplications
    | Strict
    | StrictData
    | EmptyDataDeriving
    | NumericUnderscores
    | QuantifiedConstraints
    | StarIsType
    | ImportQualifiedPost
    | CUSKs
    | StandaloneKindSignatures
    | LexicalNegation
    | FieldSelectors
    | OverloadedRecordDot
    | OverloadedRecordUpdate
    | TypeAbstractions
    | ExtendedLiterals
  type FamilyResultSig :: *
  data FamilyResultSig = NoSig | KindSig Kind | TyVarSig (TyVarBndr ())
  type FieldExp :: *
  type FieldExp = (Name, Exp)
  type FieldPat :: *
  type FieldPat = (Name, Pat)
  type Fixity :: *
  data Fixity = Fixity GHC.Types.Int FixityDirection
  type FixityDirection :: *
  data FixityDirection = InfixL | InfixR | InfixN
  type Foreign :: *
  data Foreign = ImportF Callconv Safety GHC.Base.String Name Type | ExportF Callconv GHC.Base.String Name Type
  type ForeignSrcLang :: *
  data ForeignSrcLang = LangC | LangCxx | LangObjc | LangObjcxx | LangAsm | LangJs | RawObject
  type FunDep :: *
  data FunDep = FunDep [Name] [Name]
  type Guard :: *
  data Guard = NormalG Exp | PatG [Stmt]
  type Info :: *
  data Info = ClassI Dec [InstanceDec] | ClassOpI Name Type ParentName | TyConI Dec | FamilyI Dec [InstanceDec] | PrimTyConI Name Arity Unlifted | DataConI Name Type ParentName | PatSynI Name PatSynType | VarI Name Type (GHC.Maybe.Maybe Dec) | TyVarI Name Type
  type InjectivityAnn :: *
  data InjectivityAnn = InjectivityAnn Name [Name]
  type Inline :: *
  data Inline = NoInline | Inline | Inlinable
  type InstanceDec :: *
  type InstanceDec = Dec
  type Kind :: *
  type Kind = Type
  type Lift :: forall (r :: GHC.Types.RuntimeRep). TYPE r -> Constraint
  class Lift t where
    lift :: forall (m :: * -> *). Quote m => t -> m Exp
    default lift :: forall (m :: * -> *). (r ~ GHC.Types.LiftedRep, Quote m) => t -> m Exp
    liftTyped :: forall (m :: * -> *). Quote m => t -> Code m t
    {-# MINIMAL liftTyped #-}
  type Lit :: *
  data Lit = CharL GHC.Types.Char | StringL GHC.Base.String | IntegerL GHC.Num.Integer.Integer | RationalL GHC.Real.Rational | IntPrimL GHC.Num.Integer.Integer | WordPrimL GHC.Num.Integer.Integer | FloatPrimL GHC.Real.Rational | DoublePrimL GHC.Real.Rational | StringPrimL [GHC.Word.Word8] | BytesPrimL Bytes | CharPrimL GHC.Types.Char
  type Loc :: *
  data Loc = Loc {loc_filename :: GHC.Base.String, loc_package :: GHC.Base.String, loc_module :: GHC.Base.String, loc_start :: CharPos, loc_end :: CharPos}
  type Match :: *
  data Match = Match Pat Body [Dec]
  type ModName :: *
  newtype ModName = ModName GHC.Base.String
  type Module :: *
  data Module = Module PkgName ModName
  type ModuleInfo :: *
  data ModuleInfo = ModuleInfo [Module]
  type Name :: *
  data Name = Name OccName NameFlavour
  type NameFlavour :: *
  data NameFlavour = NameS | NameQ ModName | NameU !Uniq | NameL !Uniq | NameG NameSpace PkgName ModName
  type NameIs :: *
  data NameIs = Alone | Applied | Infix
  type NameSpace :: *
  data NameSpace = VarName | DataName | TcClsName | FldName {fldParent :: !GHC.Base.String}
  type OccName :: *
  newtype OccName = OccName GHC.Base.String
  type Overlap :: *
  data Overlap = Overlappable | Overlapping | Overlaps | Incoherent
  type ParentName :: *
  type ParentName = Name
  type Pat :: *
  data Pat = LitP Lit | VarP Name | TupP [Pat] | UnboxedTupP [Pat] | UnboxedSumP Pat SumAlt SumArity | ConP Name [Type] [Pat] | InfixP Pat Name Pat | UInfixP Pat Name Pat | ParensP Pat | TildeP Pat | BangP Pat | AsP Name Pat | WildP | RecP Name [FieldPat] | ListP [Pat] | SigP Pat Type | ViewP Exp Pat
  type PatSynArgs :: *
  data PatSynArgs = PrefixPatSyn [Name] | InfixPatSyn Name Name | RecordPatSyn [Name]
  type PatSynDir :: *
  data PatSynDir = Unidir | ImplBidir | ExplBidir [Clause]
  type PatSynType :: *
  type PatSynType = Type
  type Phases :: *
  data Phases = AllPhases | FromPhase GHC.Types.Int | BeforePhase GHC.Types.Int
  type PkgName :: *
  newtype PkgName = PkgName GHC.Base.String
  type Pragma :: *
  data Pragma = InlineP Name Inline RuleMatch Phases | OpaqueP Name | SpecialiseP Name Type (GHC.Maybe.Maybe Inline) Phases | SpecialiseInstP Type | RuleP GHC.Base.String (GHC.Maybe.Maybe [TyVarBndr ()]) [RuleBndr] Exp Exp Phases | AnnP AnnTarget Exp | LineP GHC.Types.Int GHC.Base.String | CompleteP [Name] (GHC.Maybe.Maybe Name)
  type Pred :: *
  type Pred = Type
  type role Q nominal
  type Q :: * -> *
  newtype Q a = Q {unQ :: forall (m :: * -> *). Quasi m => m a}
  type Quasi :: (* -> *) -> Constraint
  class (Control.Monad.IO.Class.MonadIO m, Control.Monad.Fail.MonadFail m) => Quasi m where
    qNewName :: GHC.Base.String -> m Name
    qReport :: GHC.Types.Bool -> GHC.Base.String -> m ()
    qRecover :: forall a. m a -> m a -> m a
    qLookupName :: GHC.Types.Bool -> GHC.Base.String -> m (GHC.Maybe.Maybe Name)
    qReify :: Name -> m Info
    qReifyFixity :: Name -> m (GHC.Maybe.Maybe Fixity)
    qReifyType :: Name -> m Type
    qReifyInstances :: Name -> [Type] -> m [Dec]
    qReifyRoles :: Name -> m [Role]
    qReifyAnnotations :: forall a. Data.Data.Data a => AnnLookup -> m [a]
    qReifyModule :: Module -> m ModuleInfo
    qReifyConStrictness :: Name -> m [DecidedStrictness]
    qLocation :: m Loc
    qRunIO :: forall a. GHC.Types.IO a -> m a
    qGetPackageRoot :: m GHC.IO.FilePath
    qAddDependentFile :: GHC.IO.FilePath -> m ()
    qAddTempFile :: GHC.Base.String -> m GHC.IO.FilePath
    qAddTopDecls :: [Dec] -> m ()
    qAddForeignFilePath :: ForeignSrcLang -> GHC.Base.String -> m ()
    qAddModFinalizer :: Q () -> m ()
    qAddCorePlugin :: GHC.Base.String -> m ()
    qGetQ :: forall a. base-4.19.0.0:Data.Typeable.Internal.Typeable a => m (GHC.Maybe.Maybe a)
    qPutQ :: forall a. base-4.19.0.0:Data.Typeable.Internal.Typeable a => a -> m ()
    qIsExtEnabled :: Extension -> m GHC.Types.Bool
    qExtsEnabled :: m [Extension]
    qPutDoc :: DocLoc -> GHC.Base.String -> m ()
    qGetDoc :: DocLoc -> m (GHC.Maybe.Maybe GHC.Base.String)
    {-# MINIMAL qNewName, qReport, qRecover, qLookupName, qReify, qReifyFixity, qReifyType, qReifyInstances, qReifyRoles, qReifyAnnotations, qReifyModule, qReifyConStrictness, qLocation, qGetPackageRoot, qAddDependentFile, qAddTempFile, qAddTopDecls, qAddForeignFilePath, qAddModFinalizer, qAddCorePlugin, qGetQ, qPutQ, qIsExtEnabled, qExtsEnabled, qPutDoc, qGetDoc #-}
  type Quote :: (* -> *) -> Constraint
  class GHC.Base.Monad m => Quote m where
    newName :: GHC.Base.String -> m Name
    {-# MINIMAL newName #-}
  type Range :: *
  data Range = FromR Exp | FromThenR Exp Exp | FromToR Exp Exp | FromThenToR Exp Exp Exp
  type Role :: *
  data Role = NominalR | RepresentationalR | PhantomR | InferR
  type RuleBndr :: *
  data RuleBndr = RuleVar Name | TypedRuleVar Name Type
  type RuleMatch :: *
  data RuleMatch = ConLike | FunLike
  type Safety :: *
  data Safety = Unsafe | Safe | Interruptible
  type SourceStrictness :: *
  data SourceStrictness = NoSourceStrictness | SourceLazy | SourceStrict
  type SourceUnpackedness :: *
  data SourceUnpackedness = NoSourceUnpackedness | SourceNoUnpack | SourceUnpack
  type Specificity :: *
  data Specificity = SpecifiedSpec | InferredSpec
  type Stmt :: *
  data Stmt = BindS Pat Exp | LetS [Dec] | NoBindS Exp | ParS [[Stmt]] | RecS [Stmt]
  type Strict :: *
  type Strict = Bang
  type StrictType :: *
  type StrictType = BangType
  type SumAlt :: *
  type SumAlt = GHC.Types.Int
  type SumArity :: *
  type SumArity = GHC.Types.Int
  type role TExp nominal
  type TExp :: forall (r :: GHC.Types.RuntimeRep). TYPE r -> *
  newtype TExp a = TExp {unType :: Exp}
  type TyLit :: *
  data TyLit = NumTyLit GHC.Num.Integer.Integer | StrTyLit GHC.Base.String | CharTyLit GHC.Types.Char
  type TySynEqn :: *
  data TySynEqn = TySynEqn (GHC.Maybe.Maybe [TyVarBndr ()]) Type Type
  type TyVarBndr :: * -> *
  data TyVarBndr flag = PlainTV Name flag | KindedTV Name flag Kind
  type Type :: *
  data Type = ForallT [TyVarBndr Specificity] Cxt Type | ForallVisT [TyVarBndr ()] Type | AppT Type Type | AppKindT Type Kind | SigT Type Kind | VarT Name | ConT Name | PromotedT Name | InfixT Type Name Type | UInfixT Type Name Type | PromotedInfixT Type Name Type | PromotedUInfixT Type Name Type | ParensT Type | TupleT GHC.Types.Int | UnboxedTupleT GHC.Types.Int | UnboxedSumT SumArity | ArrowT | MulArrowT | EqualityT | ListT | PromotedTupleT GHC.Types.Int | PromotedNilT | PromotedConsT | StarT | ConstraintT | LitT TyLit | WildCardT | ImplicitParamT GHC.Base.String Type
  type TypeFamilyHead :: *
  data TypeFamilyHead = TypeFamilyHead Name [TyVarBndr BndrVis] FamilyResultSig (GHC.Maybe.Maybe InjectivityAnn)
  type Uniq :: *
  type Uniq = GHC.Num.Integer.Integer
  type Unlifted :: *
  type Unlifted = GHC.Types.Bool
  type VarBangType :: *
  type VarBangType = (Name, Bang, Type)
  type VarStrictType :: *
  type VarStrictType = VarBangType
  addCorePlugin :: GHC.Base.String -> Q ()
  addDependentFile :: GHC.IO.FilePath -> Q ()
  addForeignFile :: ForeignSrcLang -> GHC.Base.String -> Q ()
  addForeignFilePath :: ForeignSrcLang -> GHC.IO.FilePath -> Q ()
  addForeignSource :: ForeignSrcLang -> GHC.Base.String -> Q ()
  addModFinalizer :: Q () -> Q ()
  addTempFile :: GHC.Base.String -> Q GHC.IO.FilePath
  addTopDecls :: [Dec] -> Q ()
  addrToByteArray :: GHC.Types.Int -> GHC.Prim.Addr# -> Data.Array.Byte.ByteArray
  addrToByteArrayName :: Name
  badIO :: forall a. GHC.Base.String -> GHC.Types.IO a
  bindCode :: forall (m :: * -> *) a (r :: GHC.Types.RuntimeRep) (b :: TYPE r). GHC.Base.Monad m => m a -> (a -> Code m b) -> Code m b
  bindCode_ :: forall (m :: * -> *) a (r :: GHC.Types.RuntimeRep) (b :: TYPE r). GHC.Base.Monad m => m a -> Code m b -> Code m b
  cmpEq :: GHC.Types.Ordering -> GHC.Types.Bool
  compareBytes :: Bytes -> Bytes -> GHC.Types.Ordering
  counter :: GHC.IORef.IORef Uniq
  dataToExpQ :: forall (m :: * -> *) a. (Quote m, Data.Data.Data a) => (forall b. Data.Data.Data b => b -> GHC.Maybe.Maybe (m Exp)) -> a -> m Exp
  dataToPatQ :: forall (m :: * -> *) a. (Quote m, Data.Data.Data a) => (forall b. Data.Data.Data b => b -> GHC.Maybe.Maybe (m Pat)) -> a -> m Pat
  dataToQa :: forall (m :: * -> *) a k q. (Quote m, Data.Data.Data a) => (Name -> k) -> (Lit -> m q) -> (k -> [m q] -> m q) -> (forall b. Data.Data.Data b => b -> GHC.Maybe.Maybe (m q)) -> a -> m q
  defaultFixity :: Fixity
  eqBytes :: Bytes -> Bytes -> GHC.Types.Bool
  extsEnabled :: Q [Extension]
  falseName :: Name
  getDoc :: DocLoc -> Q (GHC.Maybe.Maybe GHC.Base.String)
  getPackageRoot :: Q GHC.IO.FilePath
  getQ :: forall a. base-4.19.0.0:Data.Typeable.Internal.Typeable a => Q (GHC.Maybe.Maybe a)
  get_cons_names :: Con -> [Name]
  hoistCode :: forall (m :: * -> *) (n :: * -> *) (r :: GHC.Types.RuntimeRep) (a :: TYPE r). GHC.Base.Monad m => (forall x. m x -> n x) -> Code m a -> Code n a
  isExtEnabled :: Extension -> Q GHC.Types.Bool
  isInstance :: Name -> [Type] -> Q GHC.Types.Bool
  joinCode :: forall (m :: * -> *) (r :: GHC.Types.RuntimeRep) (a :: TYPE r). GHC.Base.Monad m => m (Code m a) -> Code m a
  justName :: Name
  leftName :: Name
  liftCode :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r) (m :: * -> *). m (TExp a) -> Code m a
  liftData :: forall (m :: * -> *) a. (Quote m, Data.Data.Data a) => a -> m Exp
  liftString :: forall (m :: * -> *). Quote m => GHC.Base.String -> m Exp
  location :: Q Loc
  lookupName :: GHC.Types.Bool -> GHC.Base.String -> Q (GHC.Maybe.Maybe Name)
  lookupTypeName :: GHC.Base.String -> Q (GHC.Maybe.Maybe Name)
  lookupValueName :: GHC.Base.String -> Q (GHC.Maybe.Maybe Name)
  makeRelativeToProject :: GHC.IO.FilePath -> Q GHC.IO.FilePath
  manyName :: Name
  maxPrecedence :: GHC.Types.Int
  memcmp :: forall a b. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr b -> Foreign.C.Types.CSize -> GHC.Types.IO Foreign.C.Types.CInt
  mkModName :: GHC.Base.String -> ModName
  mkName :: GHC.Base.String -> Name
  mkNameG :: NameSpace -> GHC.Base.String -> GHC.Base.String -> GHC.Base.String -> Name
  mkNameG_d :: GHC.Base.String -> GHC.Base.String -> GHC.Base.String -> Name
  mkNameG_fld :: GHC.Base.String -> GHC.Base.String -> GHC.Base.String -> GHC.Base.String -> Name
  mkNameG_tc :: GHC.Base.String -> GHC.Base.String -> GHC.Base.String -> Name
  mkNameG_v :: GHC.Base.String -> GHC.Base.String -> GHC.Base.String -> Name
  mkNameL :: GHC.Base.String -> Uniq -> Name
  mkNameQ :: GHC.Base.String -> GHC.Base.String -> Name
  mkNameS :: GHC.Base.String -> Name
  mkNameU :: GHC.Base.String -> Uniq -> Name
  mkOccName :: GHC.Base.String -> OccName
  mkPkgName :: GHC.Base.String -> PkgName
  mk_tup_name :: GHC.Types.Int -> NameSpace -> GHC.Types.Bool -> Name
  modString :: ModName -> GHC.Base.String
  nameBase :: Name -> GHC.Base.String
  nameModule :: Name -> GHC.Maybe.Maybe GHC.Base.String
  namePackage :: Name -> GHC.Maybe.Maybe GHC.Base.String
  nameSpace :: Name -> GHC.Maybe.Maybe NameSpace
  newDeclarationGroup :: Q [Dec]
  newNameIO :: GHC.Base.String -> GHC.Types.IO Name
  nonemptyName :: Name
  nothingName :: Name
  occString :: OccName -> GHC.Base.String
  oneName :: Name
  pkgString :: PkgName -> GHC.Base.String
  putDoc :: DocLoc -> GHC.Base.String -> Q ()
  putQ :: forall a. base-4.19.0.0:Data.Typeable.Internal.Typeable a => a -> Q ()
  recover :: forall a. Q a -> Q a -> Q a
  reify :: Name -> Q Info
  reifyAnnotations :: forall a. Data.Data.Data a => AnnLookup -> Q [a]
  reifyConStrictness :: Name -> Q [DecidedStrictness]
  reifyFixity :: Name -> Q (GHC.Maybe.Maybe Fixity)
  reifyInstances :: Name -> [Type] -> Q [InstanceDec]
  reifyModule :: Module -> Q ModuleInfo
  reifyRoles :: Name -> Q [Role]
  reifyType :: Name -> Q Type
  report :: GHC.Types.Bool -> GHC.Base.String -> Q ()
  reportError :: GHC.Base.String -> Q ()
  reportWarning :: GHC.Base.String -> Q ()
  rightName :: Name
  runIO :: forall a. GHC.Types.IO a -> Q a
  runQ :: forall (m :: * -> *) a. Quasi m => Q a -> m a
  sequenceQ :: forall (m :: * -> *) a. GHC.Base.Monad m => [m a] -> m [a]
  showName :: Name -> GHC.Base.String
  showName' :: NameIs -> Name -> GHC.Base.String
  thenCmp :: GHC.Types.Ordering -> GHC.Types.Ordering -> GHC.Types.Ordering
  trueName :: Name
  tupleDataName :: GHC.Types.Int -> Name
  tupleTypeName :: GHC.Types.Int -> Name
  unTypeCode :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r) (m :: * -> *). Quote m => Code m a -> m Exp
  unTypeQ :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r) (m :: * -> *). Quote m => m (TExp a) -> m Exp
  unboxedSumDataName :: SumAlt -> SumArity -> Name
  unboxedSumTypeName :: SumArity -> Name
  unboxedTupleDataName :: GHC.Types.Int -> Name
  unboxedTupleTypeName :: GHC.Types.Int -> Name
  unsafeCodeCoerce :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r) (m :: * -> *). Quote m => m Exp -> Code m a
  unsafeTExpCoerce :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r) (m :: * -> *). Quote m => m Exp -> m (TExp a)


-- Instances:
instance Control.Monad.Fail.MonadFail Language.Haskell.TH.Syntax.Q -- Defined in ‘Language.Haskell.TH.Syntax’
instance Control.Monad.Fix.MonadFix Language.Haskell.TH.Syntax.Q -- Defined in ‘Language.Haskell.TH.Syntax’
instance Control.Monad.IO.Class.MonadIO Language.Haskell.TH.Syntax.Q -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.AnnLookup -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.AnnTarget -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Bang -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.BndrVis -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Body -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Bytes -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Callconv -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Clause -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Con -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Dec -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.DecidedStrictness -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.DerivClause -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.DerivStrategy -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.DocLoc -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Exp -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.FamilyResultSig -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Fixity -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.FixityDirection -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Foreign -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.FunDep -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Guard -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Info -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.InjectivityAnn -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Inline -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Lit -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Loc -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Match -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.ModName -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Module -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.ModuleInfo -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Name -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.NameFlavour -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.NameSpace -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.OccName -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Overlap -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Pat -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.PatSynArgs -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.PatSynDir -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Phases -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.PkgName -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Pragma -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Range -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Role -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.RuleBndr -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.RuleMatch -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Safety -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.SourceStrictness -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.SourceUnpackedness -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Specificity -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Stmt -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.TyLit -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.TySynEqn -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall flag. Data.Data.Data flag => Data.Data.Data (Language.Haskell.TH.Syntax.TyVarBndr flag) -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.Type -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Data.Data Language.Haskell.TH.Syntax.TypeFamilyHead -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Foldable.Foldable Language.Haskell.TH.Syntax.TyVarBndr -- Defined in ‘Language.Haskell.TH.Syntax’
instance Data.Traversable.Traversable Language.Haskell.TH.Syntax.TyVarBndr -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Base.Applicative Language.Haskell.TH.Syntax.Q -- Defined in ‘Language.Haskell.TH.Syntax’
instance [safe] GHC.Base.Applicative Language.Haskell.TH.PprLib.PprM -- Defined in ‘Language.Haskell.TH.PprLib’
instance GHC.Base.Functor Language.Haskell.TH.Syntax.Q -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Base.Functor Language.Haskell.TH.Syntax.TyVarBndr -- Defined in ‘Language.Haskell.TH.Syntax’
instance [safe] GHC.Base.Functor Language.Haskell.TH.PprLib.PprM -- Defined in ‘Language.Haskell.TH.PprLib’
instance GHC.Base.Monad Language.Haskell.TH.Syntax.Q -- Defined in ‘Language.Haskell.TH.Syntax’
instance [safe] GHC.Base.Monad Language.Haskell.TH.PprLib.PprM -- Defined in ‘Language.Haskell.TH.PprLib’
instance forall a. GHC.Base.Monoid a => GHC.Base.Monoid (Language.Haskell.TH.Syntax.Q a) -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall a. GHC.Base.Semigroup a => GHC.Base.Semigroup (Language.Haskell.TH.Syntax.Q a) -- Defined in ‘Language.Haskell.TH.Syntax’
instance [safe] GHC.Enum.Bounded GHC.LanguageExtensions.Type.Extension -- Defined in ‘GHC.LanguageExtensions.Type’
instance [safe] GHC.Enum.Enum GHC.LanguageExtensions.Type.Extension -- Defined in ‘GHC.LanguageExtensions.Type’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.AnnLookup -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.AnnTarget -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Bang -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.BndrVis -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Body -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Bytes -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Callconv -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Clause -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Con -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Dec -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.DecidedStrictness -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.DerivClause -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.DerivStrategy -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.DocLoc -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Exp -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FamilyResultSig -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Fixity -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FixityDirection -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Foreign -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FunDep -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Guard -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Info -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.InjectivityAnn -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Inline -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Lit -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Loc -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Match -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.ModName -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Module -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.ModuleInfo -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Name -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.NameFlavour -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.NameSpace -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.OccName -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Overlap -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Pat -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.PatSynArgs -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.PatSynDir -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Phases -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.PkgName -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Pragma -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Range -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Role -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.RuleBndr -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.RuleMatch -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Safety -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.SourceStrictness -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.SourceUnpackedness -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Specificity -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Stmt -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TyLit -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TySynEqn -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall flag. GHC.Generics.Generic (Language.Haskell.TH.Syntax.TyVarBndr flag) -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Type -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TypeFamilyHead -- Defined in ‘Language.Haskell.TH.Syntax’
instance [safe] GHC.Generics.Generic GHC.LanguageExtensions.Type.Extension -- Defined in ‘GHC.LanguageExtensions.Type’
instance [safe] GHC.Generics.Generic GHC.ForeignSrcLang.Type.ForeignSrcLang -- Defined in ‘GHC.ForeignSrcLang.Type’
instance GHC.Show.Show Language.Haskell.TH.Syntax.AnnLookup -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.AnnTarget -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Bang -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.BndrVis -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Body -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Bytes -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Callconv -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Clause -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Con -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Dec -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.DecidedStrictness -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.DerivClause -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.DerivStrategy -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.DocLoc -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Exp -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.FamilyResultSig -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Fixity -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.FixityDirection -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Foreign -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.FunDep -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Guard -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Info -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.InjectivityAnn -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Inline -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Lit -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Loc -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Match -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.ModName -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Module -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.ModuleInfo -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Name -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.NameFlavour -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.NameSpace -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.OccName -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Overlap -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Pat -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.PatSynArgs -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.PatSynDir -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Phases -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.PkgName -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Pragma -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Range -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Role -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.RuleBndr -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.RuleMatch -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Safety -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.SourceStrictness -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.SourceUnpackedness -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Specificity -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Stmt -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.TyLit -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.TySynEqn -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall flag. GHC.Show.Show flag => GHC.Show.Show (Language.Haskell.TH.Syntax.TyVarBndr flag) -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.Type -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Show.Show Language.Haskell.TH.Syntax.TypeFamilyHead -- Defined in ‘Language.Haskell.TH.Syntax’
instance [safe] GHC.Show.Show GHC.LanguageExtensions.Type.Extension -- Defined in ‘GHC.LanguageExtensions.Type’
instance [safe] GHC.Show.Show Language.Haskell.TH.Ppr.ForallVisFlag -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] GHC.Show.Show Language.Haskell.TH.PprLib.Doc -- Defined in ‘Language.Haskell.TH.PprLib’
instance [safe] GHC.Show.Show GHC.ForeignSrcLang.Type.ForeignSrcLang -- Defined in ‘GHC.ForeignSrcLang.Type’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.AnnLookup -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.AnnTarget -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Bang -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.BndrVis -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Body -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Bytes -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Callconv -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Clause -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Con -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Dec -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.DecidedStrictness -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.DerivClause -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.DerivStrategy -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.DocLoc -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Exp -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FamilyResultSig -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Fixity -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FixityDirection -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Foreign -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FunDep -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Guard -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Info -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.InjectivityAnn -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Inline -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Lit -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Loc -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Match -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.ModName -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Module -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.ModuleInfo -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Name -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.NameFlavour -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.NameSpace -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.OccName -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Overlap -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Pat -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.PatSynArgs -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.PatSynDir -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Phases -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.PkgName -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Pragma -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Range -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Role -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.RuleBndr -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.RuleMatch -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Safety -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.SourceStrictness -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.SourceUnpackedness -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Specificity -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Stmt -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TyLit -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TySynEqn -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall flag. GHC.Classes.Eq flag => GHC.Classes.Eq (Language.Haskell.TH.Syntax.TyVarBndr flag) -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Type -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TypeFamilyHead -- Defined in ‘Language.Haskell.TH.Syntax’
instance [safe] GHC.Classes.Eq GHC.LanguageExtensions.Type.Extension -- Defined in ‘GHC.LanguageExtensions.Type’
instance [safe] GHC.Classes.Eq GHC.ForeignSrcLang.Type.ForeignSrcLang -- Defined in ‘GHC.ForeignSrcLang.Type’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.AnnLookup -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.AnnTarget -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Bang -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.BndrVis -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Body -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Bytes -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Callconv -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Clause -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Con -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Dec -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.DecidedStrictness -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.DerivClause -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.DerivStrategy -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.DocLoc -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Exp -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FamilyResultSig -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Fixity -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FixityDirection -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Foreign -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FunDep -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Guard -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Info -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.InjectivityAnn -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Inline -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Lit -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Loc -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Match -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.ModName -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Module -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.ModuleInfo -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Name -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.NameFlavour -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.NameSpace -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.OccName -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Overlap -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Pat -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.PatSynArgs -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.PatSynDir -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Phases -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.PkgName -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Pragma -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Range -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Role -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.RuleBndr -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.RuleMatch -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Safety -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.SourceStrictness -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.SourceUnpackedness -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Specificity -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Stmt -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TyLit -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TySynEqn -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall flag. GHC.Classes.Ord flag => GHC.Classes.Ord (Language.Haskell.TH.Syntax.TyVarBndr flag) -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Type -- Defined in ‘Language.Haskell.TH.Syntax’
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TypeFamilyHead -- Defined in ‘Language.Haskell.TH.Syntax’
instance [safe] GHC.Classes.Ord GHC.LanguageExtensions.Type.Extension -- Defined in ‘GHC.LanguageExtensions.Type’
instance [safe] Language.Haskell.TH.Lib.DefaultBndrFlag Language.Haskell.TH.Syntax.BndrVis -- Defined in ‘Language.Haskell.TH.Lib’
instance [safe] Language.Haskell.TH.Lib.DefaultBndrFlag Language.Haskell.TH.Syntax.Specificity -- Defined in ‘Language.Haskell.TH.Lib’
instance [safe] Language.Haskell.TH.Lib.DefaultBndrFlag () -- Defined in ‘Language.Haskell.TH.Lib’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Bang -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Clause -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Con -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Dec -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.DecidedStrictness -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Exp -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.FamilyResultSig -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Foreign -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.FunDep -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Info -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.InjectivityAnn -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Inline -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] forall a. Language.Haskell.TH.Ppr.Ppr a => Language.Haskell.TH.Ppr.Ppr [a] -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Lit -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Loc -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Match -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Module -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.ModuleInfo -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Name -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Pat -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.PatSynArgs -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.PatSynDir -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Phases -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Pragma -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Range -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Role -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.RuleBndr -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.RuleMatch -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.SourceStrictness -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.SourceUnpackedness -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Stmt -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.TyLit -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] forall flag. Language.Haskell.TH.Ppr.PprFlag flag => Language.Haskell.TH.Ppr.Ppr (Language.Haskell.TH.Syntax.TyVarBndr flag) -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Type -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Ppr.TypeArg -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.PprFlag Language.Haskell.TH.Syntax.BndrVis -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.PprFlag Language.Haskell.TH.Syntax.Specificity -- Defined in ‘Language.Haskell.TH.Ppr’
instance [safe] Language.Haskell.TH.Ppr.PprFlag () -- Defined in ‘Language.Haskell.TH.Ppr’
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Bool -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift Data.Array.Byte.ByteArray -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Char -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Double -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall a b. (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (Data.Either.Either a b) -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall k (a :: k). Language.Haskell.TH.Syntax.Lift (Data.Fixed.Fixed a) -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Float -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Int -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int16 -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int32 -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int64 -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int8 -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Num.Integer.Integer -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall a. Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift [a] -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall a. Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (GHC.Maybe.Maybe a) -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Num.Natural.Natural -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall a. Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (GHC.Base.NonEmpty a) -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall a. GHC.Real.Integral a => Language.Haskell.TH.Syntax.Lift (GHC.Real.Ratio a) -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall a b. (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (a, b) -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall a b c. (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c) => Language.Haskell.TH.Syntax.Lift (a, b, c) -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall a b c d. (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d) => Language.Haskell.TH.Syntax.Lift (a, b, c, d) -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall a b c d e. (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e) -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall a b c d e f. (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e, f) -- Defined in ‘Language.Haskell.TH.Syntax’
instance forall a b c d e f g. (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f, Language.Haskell.TH.Syntax.Lift g) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e, f, g) -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift () -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Base.Void -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Word -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word16 -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word32 -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word64 -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word8 -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Quasi GHC.Types.IO -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Quasi Language.Haskell.TH.Syntax.Q -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Quote GHC.Types.IO -- Defined in ‘Language.Haskell.TH.Syntax’
instance Language.Haskell.TH.Syntax.Quote Language.Haskell.TH.Syntax.Q -- Defined in ‘Language.Haskell.TH.Syntax’
